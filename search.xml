<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>为何MySQL使用B+树，MongoDB使用B树</title>
    <url>/2020/04/22/mysqlb-monb/</url>
    <content><![CDATA[<p>今天在网上看到一篇很有意思的关于B+树和B树的探讨，值得收藏，所以写下此篇文章。<br>网上有些文章会写到B树不适合做文件存储系统的索引结构，那么它真的那么不堪吗？</p>
<h3 id="一、B树和B-树的结构与特点"><a href="#一、B树和B-树的结构与特点" class="headerlink" title="一、B树和B+树的结构与特点"></a>一、B树和B+树的结构与特点</h3><p>首先，看一下B树和B+树的结构图：<br>B树：<br><img src="btree.png" alt="1"></p>
<p>通过上图可以发现B树的特点为：</p>
<ul>
<li>1、每个节点都存储数据data</li>
<li>2、叶子节点之间无相邻指针关联</li>
</ul>
<p>B+树：<br><img src="bptree.png" alt="2"></p>
<p>通过上图对B+树的结构的观察，其特点为：</p>
<ul>
<li>1、数据data只存储在叶子节点上</li>
<li>2、所有叶子节点上都通过指针进行关联</li>
</ul>
<p>所以，综上观察，得出以下结论：<br>1、B树存储结构中，数据存储在各个节点上，在做单一查询时，其查询性能不稳定，最好的情况为O(1)，但是整体来说，单一查询还是B树较为合适。<br>但在B树上做遍历查询时，由于其没有指针对各节点进行关联，所以效率不高，每次遍历都需要从根节点开始查找。<br>2、B+树存储结构中，由于其数据只存储叶子节点上，所以在做单一查询时，查询性能固定，每次都从根节点开始查找，最后查到叶子节点上。<br>但在B+树上做遍历查询时，由于其叶子节点上存在关联指针，所以遍历时不需要回到根节点遍历，只需要对叶子节点进行遍历即可，所以B+树的范围查询效率较高。</p>
<h3 id="二、继续分析"><a href="#二、继续分析" class="headerlink" title="二、继续分析"></a>二、继续分析</h3><p>那么是不是可以这么想：由于MongoDB中主要做单一查询，所以用B树呢？而MySQL遍历查询场景应用比较频繁，所以采用B+树呢？<br>那么问题来了：为什么MySQL中做数据遍历多，而MongoDB中数据遍历少呢？</p>
<p>带着这些疑问，继续往下分析：<br>我们知道，MySQL属于关系型数据库，MongoDB属于非关系型数据库。<br>举个例子：此时，我们有两个逻辑需要建表存储数据，分别为：<br>1、学生信息；2、班级信息。<br>其逻辑关系为：一个班级对应多个学生，一个学生只能有一个班级，即一对多的关系<br>在关系型数据库中分为一对一，一对多，多对多三种关系，其中一对多的关系，使用两张表即可：<br><img src="table.png" alt="3"></p>
<p>此时在查询class_name=’一班’的所有学生时，sql为：【class_name列建立索引】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_student <span class="keyword">where</span> class_id <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> test_class <span class="keyword">where</span> class_name=<span class="string">'一班'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>以上sql就涉及到数据遍历查询的操作。也就是说会到B+树的叶子节点上进行遍历查询。</p>
<p>在非关系型数据库MongoDB中，如果以MySQL设计表的思想去建立数据类型就是：<br><img src="mongo.png" alt="4"><br>以MySQL的思想去设计MongoDB的话，对于MongoDB的B树结构就是一种浪费了。<br>MongoDB之所以使用B树结构，肯定是不希望使用者以关系型数据库的思想去建立数据表结构。<br>所以，考虑B树的结构，在MongoDB中，应该这样创建表：<br><img src="mongo-2.png" alt="5"></p>
<p>此时，查询班级为 “一班” 的查询语句就为：【class_name列建索引】</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.class</span><span class="selector-class">.find</span>( &#123;<span class="attribute">class_name</span>: <span class="string">'一班'</span>&#125; )</span><br></pre></td></tr></table></figure>
<p>这样就是一个单一查询，不需要遍历逐行匹配，最好的情况下，一次就能查到。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>由于关系型数据库和非关系型数据库在设计方式上的不同，导致在关系型数据库中，遍历查询十分普遍，且严格来说B+树的单一查询效率也很均衡，所以采用B+树比较合理。<br>而非关系型数据库中，单一查询十分常见，所以采用B树，相比较B+树来说，虽然效率不均衡，但是总体来说单一查询效率还是比B+树高的。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL中表自增id用完了是否还能插入数据？</title>
    <url>/2020/04/07/mysql-auto-max/</url>
    <content><![CDATA[<p>从未考虑过自增id能用完这个问题，最近看到相关文章，那么我也来做个实验，看看具体情况。</p>
<h3 id="一、实验环境"><a href="#一、实验环境" class="headerlink" title="一、实验环境"></a>一、实验环境</h3><ul>
<li><p>1、MySQL版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| version() |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 8.0.18    |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、实验表建表语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4294967294</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="二、相关内容"><a href="#二、相关内容" class="headerlink" title="二、相关内容"></a>二、相关内容</h3><ul>
<li>1、自增id</li>
</ul>
<p>在MySQL的InnoDB引擎中，一般来说，建表时都建议定义一个自增id作为其主键值，其优点在于：<br>1.自增id的有序递增；<br>2.有序递增的主键使得插入数据时，不会导致数据页分裂次多过多，造成数据页碎片化严重；<br>3.聚簇索引查询时，根据有序递增的顺序查询更快速；<br>4.数据页碎片化不严重，就不会浪费更多的磁盘空间。</p>
<p>实验表中，我设置实验表t默认自增从4294967294开始，这是因为int值占4个字节，其unsigned的取值范围为0~4294967295，可以看下正常插入数据到顶点时，会出现什么情况。</p>
<h3 id="三、实验开始"><a href="#三、实验开始" class="headerlink" title="三、实验开始"></a>三、实验开始</h3><p>1、插入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t values(null);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t values(null);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| id         |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| 4294967294 |</span><br><span class="line">| 4294967295 |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t values(null);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry '4294967295' for key 'PRIMARY'</span><br></pre></td></tr></table></figure>
<p>可以看到，在插入第二条数据时，id值已经到达了int值的取值范围顶点，此时继续插入数据，则会报错提示：主键重复<br>那么也就可以得出结论：<br><strong>当自增主键用完时，将不能再继续插入新数据。MySQL底层在自增主键取值到达顶点时，依旧使用最大值作为主键值插入，所以会报错为主键重复</strong></p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>实验很简单的做完了，也得出了疑问中的结论。<br>MySQL中表自增id用完了，就无法继续成功插入新数据，所以说在生产上，应尽量考虑到这种情况，以免生产环境出现问题时手忙脚乱。<br>但是，一般来说int unsigned在业务中是足够用的，不需要考虑的太多，如果真的不够用了，那么可以用bigint unsigned（8个字节）来作为自增主键值。</p>
<p>还有一种情况是，当表未指定主键id时：<br>当MySQL InnoDB数据表未指定主键id时，InnoDB会自动给该表创建一个不可见序列值（记为row_id）作为该表的主键id。<br>需要注意的是，InnoDB在全局中维护了一个dictsys.row_id，所有未定义主键的表共用该row_id配置，<br>也就是说，每插入一条数据都将row_id作为主键，然后将全局row_id +1，然后其他表继续使用。</p>
<p>该row_id长度为6字节，使用bigint unsigned类型（使用了该类型，却只用6字节的数据），<br>这样就会存在一个问题：row_id递增到 <code>2的48次方减1</code> 时row_id再加1就会变为0，存在风险。<br>而且，前面介绍了主键逐个递增的好处，所以说，最好的方法还是定义一个主键，而不是使用InnoDB创建的自动主键。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL中join关联查询是如何执行的？</title>
    <url>/2020/02/29/mysql-join/</url>
    <content><![CDATA[<p>在上一篇文章&lt;MySQL中如何更好的使用Limit？&gt;中，我们最后写到limit优化的方式之一就是用到了join关联查询，那么多表的关联查询是如何执行的呢？<br>带着这个疑问，我们一起探究下join关联查询的执行步骤！</p>
<h3 id="一、实验环境"><a href="#一、实验环境" class="headerlink" title="一、实验环境"></a>一、实验环境</h3><ul>
<li><p>1、MySQL版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| version() |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 8.0.18    |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、实验表结构 t1数据100条，t2数据1000条</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc t1;</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| id    | int(11) | NO   | PRI | NULL    |       |</span><br><span class="line">| a     | int(11) | YES  | MUL | NULL    |       |</span><br><span class="line">| b     | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t1;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|      100 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">desc</span> t2;</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| id    | int(11) | NO   | PRI | NULL    |       |</span><br><span class="line">| a     | int(11) | YES  | MUL | NULL    |       |</span><br><span class="line">| b     | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t2;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|     1000 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="二、驱动表"><a href="#二、驱动表" class="headerlink" title="二、驱动表"></a>二、驱动表</h3><ul>
<li>1、驱动表的概念</li>
</ul>
<p>提到join，就不得不说到驱动表。<br>驱动表：在关联查询中首先执行的表，叫做驱动表。在使用join时，默认会有MySQL的优化器去选择合适表作为驱动表。</p>
<p>在join语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。</p>
<p>执行以下sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 join t2 on t1.a=t2.a;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref       | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | a             | NULL | NULL    | NULL      |  100 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ref  | a             | a    | 5       | test.t1.a |    1 |   100.00 | NULL        |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>在 explain 中，第一行的表就是驱动表。可以看出，上面的sql语句的驱动表为t1表。<br>根据row字段信息，可以看出，t1表进行了全表扫描，t2表使用了字段a上的索引。</p>
<ul>
<li>2、如何选取驱动表</li>
</ul>
<p><em>a. MySQL自动选取</em></p>
<p>一般来说，MySQL会选取小表作为驱动表，注意，这里的小表不是总数据量少的那张表，而是根据sql中的表过滤条件去决定的。</p>
<p>执行以下sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sql1</span></span><br><span class="line">mysql&gt; explain select * from t1 join t2 on t2.b=t1.b;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  100 |   100.00 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1000 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sql2</span></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> t2.b=t1.b <span class="keyword">where</span> t2.id&lt;<span class="number">50</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   49 |   100.00 | Using where                                        |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |  100 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>以上实验可以看出：</p>
<p>sql1的驱动表为t1表，因为在没有其他过滤条件的情况下，t1表只有100条数据，优先以小表作为驱动表。<br>sql2的驱动表为t2表，因为where条件中的 <code>t2.id&lt;50</code> 使得t2表过滤之后只有49条数据，所以t2表是小表。</p>
<p><em>b. 手动选取</em></p>
<p>使用 straight_join 代替 join 其将强制选取第一张表作为驱动表。<br>执行下上面的sql2，将join换为straight_join。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 straight_join t2 on t2.b=t1.b where t2.id&lt;50;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |  100 |   100.00 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   49 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="三、关联查询算法"><a href="#三、关联查询算法" class="headerlink" title="三、关联查询算法"></a>三、关联查询算法</h3><p>MySQL中join关联查询共有四种查询算法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Simple Nested-Loop join,</span><br><span class="line">Block Nested-Loop join,</span><br><span class="line">Index Nested-Loop join，</span><br><span class="line">Batched Key Access join</span><br></pre></td></tr></table></figure>
<p>在使用索引关联的情况下，有Index Nested-Loop join和Batched Key Access join两种算法；<br>在不使用索引关联的情况下，有Simple Nested-Loop join和Block Nested-Loop join两种算法。</p>
<ul>
<li>1、索引关联情况（t1,t2表的a字段有索引)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 join t2 on t2.a=t1.a where t2.id&lt;50;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref       | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY,a     | PRIMARY | 4       | NULL      |   49 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref   | a             | a       | 5       | test.t2.a |    1 |   100.00 | NULL        |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>执行步骤为：<br>1、MySQL优化器根据过滤条件得出驱动表为t2；<br>2、根据 <code>t2.id&lt;50，t2.*</code> 查询到一行t2.id=1的数据，拿到t2.a的值和t1.a做关联；<br>3、搜寻t1.a索引树，找到t1.id，回表查询t1.*数据；<br>4、组成整体数据行，放入结果集中；<br>5、循环1-4步骤，直到取完数据。</p>
<p>执行过程图：<br><img src="join-index.jpg" alt="1"></p>
<p>以上流程就是Index Nested-Loop join算法（索引嵌套循环连接）的执行过程，可以发现，如果在被驱动表(t.1)的索引树上不存在需要查询的所有字段，则需要回表到聚簇索引上查询，<br>每次回表都是一次随机查询，对于MySQL来说，性能并不是很好。</p>
<p>因此，MySQL在5.6引入了Batched Key Access join算法（成批密钥访问连接）。<br>针对上面的Index Nested-Loop join算法实例，该算法的执行逻辑为：<br>1、MySQL优化器根据过滤条件得出驱动表为t2；<br>2、根据 <code>t2.id&lt;50，t2.*</code> 查询到一行t2.id=1的数据；<br>3、将第2步的行数据放到join_buffer中，循环第二步，直到join_buffer放满；<br>4、根据join_buffer中的t2.a的值和t1.a做关联，搜寻t1.a索引树，找到t1.id；<br>5、将第3步的索引数据放到read_rnd_buffer中，并将read_rnd_buffer中的t1.id排序；<br>6、循环3~4步骤，直到read_rnd_buffer放满；<br>7、通过MRR(Multi-Range Read)将read_rnd_buffer中的数据进行回表查询；<br>8、将回表的查询结果和join_buffer中的数据组合成整体数据行，放入结果集中。</p>
<p>执行过程图：<br><img src="join-bka.jpg" alt="2"></p>
<p>在以上Batched Key Access join算法执行步骤中，其优化了两点：<br>1、驱动表查询到的行数据先缓存在join_buffer中，之后批量访问被驱动表索引树；<br>2、被驱动表索引行数据缓存在read_rnd_buffer中并按照主键进行排序，之后MRR顺序回表查询数据。<br>Batched Key Access join算法避免了多次访问被驱动表索引树，并将随机回表变为顺序回表，大大提升了查询效率。</p>
<ul>
<li>2、无索引关联情况（t1,t2表的b字段无索引）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 join t2 on t2.b=t1.b where t2.id&lt;50;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   49 |   100.00 | Using where                                        |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |  100 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>根据explain sql执行计划，我们在Extra字段中可以看到，其使用到了Block Nested-Loop join算法（块嵌套循环连接）。<br>Block Nested-Loop join算法和Batched Key Access join算法执行步骤类似，只是没有read_rnd_buffer。</p>
<p>其执行步骤为：<br>1、MySQL优化器根据过滤条件得出驱动表为t1；<br>2、根据 <code>t2.id&lt;50，t2.*</code> 查询到一行t2.id=1的数据；<br>3、将第2步的行数据放到join_buffer中，循环第二步，直到join_buffer放满；<br>4、根据join_buffer中的t2.b的值和t1.b做关联，全表扫描t1，批量取出行数据；<br>5、将全表扫描查询结果和join_buffer中的数据组合成整体数据行，放入结果集中。</p>
<p>执行过程图：<br><img src="join-bnl.jpg" alt="3"></p>
<p>关于Simple Nested-Loop join算法，MySQL已经不再使用，其执行步骤为Block Nested-Loop join算法执行步骤中去掉join_buffer内容。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>此篇文章我们介绍了join关联查询下，驱动表的概念以及四种关联查询算法。</p>
<p>Batched Key Access join算法（BKA）是最优的join优化解决方案，使用BKA可以大大的提高sql的执行效率。<br>在MySQL中Batched Key Access join算法默认并未开启，需要在执行sql前启用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动BKA &amp; MMR</span></span><br><span class="line">mysql&gt; set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select t1.*,t2.* from t1 join t2 on t2.a=t1.a where t2.id&lt;80;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+----------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref       | rows | filtered | Extra                                  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+----------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY,a     | PRIMARY | 4       | NULL      |   79 |   100.00 | Using where                            |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref   | a             | a       | 5       | test.t2.a |    1 |   100.00 | Using join buffer (Batched Key Access) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+----------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>关联查询在无索引关联时，对被驱动表的全表扫描十分浪费资源，所以在平时我们编写关联sql查询时，在数据表中有大量数据时，应尽量避免无索引关联的情况，on后的语句中的关联条件应为其建立必要的索引，实在无法为字段建立索引，则应考虑其他方式进行关联查询。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL中如何更好的使用Limit？</title>
    <url>/2020/02/12/mysql-limit/</url>
    <content><![CDATA[<p>在业务中实现分页功能就离不了MySQL的limit语句，而随着数据表中数据量的增加，则不可避免会导致查询时偏移量过大。<br>我们知道随着偏移量的增大，limit语句的耗时会增加，接下来我们就探讨下如何去更好的处理limit的耗时问题。</p>
<h3 id="一、实验"><a href="#一、实验" class="headerlink" title="一、实验"></a>一、实验</h3><p>1、MySQL版本：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| version() |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 8.0.18    |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>2、实验表结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc t213;</span><br><span class="line">+<span class="comment">-------+------------------+------+-----+---------+----------------+</span></span><br><span class="line">| Field | Type             | Null | Key | Default | Extra          |</span><br><span class="line">+<span class="comment">-------+------------------+------+-----+---------+----------------+</span></span><br><span class="line">| id    | int(10)          | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| a     | int(10) unsigned | NO   | MUL | 0       |                |</span><br><span class="line">| b     | int(10) unsigned | NO   |     | 0       |                |</span><br><span class="line">+<span class="comment">-------+------------------+------+-----+---------+----------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>其中，id为自增主键，字段a为普通索引</p>
<p>3、实验数据量近200万：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(*) from t213;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|  1979311 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.11</span> sec)</span><br></pre></td></tr></table></figure>

<p>4、开始测试：<br>当偏移量为100万时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t213 where a=4 limit 1000000,10;</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| id      | a | b   |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| 1000001 | 4 | 123 |</span><br><span class="line">| 1000002 | 4 | 123 |</span><br><span class="line">| 1000003 | 4 | 123 |</span><br><span class="line">| 1000004 | 4 | 123 |</span><br><span class="line">| 1000005 | 4 | 123 |</span><br><span class="line">| 1000006 | 4 | 123 |</span><br><span class="line">| 1000007 | 4 | 123 |</span><br><span class="line">| 1000008 | 4 | 123 |</span><br><span class="line">| 1000009 | 4 | 123 |</span><br><span class="line">| 1000010 | 4 | 123 |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">2.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>我们知道以上的方法效率并不高，一般我们在数据量大的数据表中，不直接limit，而是通过连接去先查询id，再查询字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select c1.id, c1.a, c1.b from t213 c1 right join(select id from t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</span><br><span class="line">+<span class="comment">---------+------+------+</span></span><br><span class="line">| id      | a    | b    |</span><br><span class="line">+<span class="comment">---------+------+------+</span></span><br><span class="line">| 1000001 |    4 |  123 |</span><br><span class="line">| 1000002 |    4 |  123 |</span><br><span class="line">| 1000003 |    4 |  123 |</span><br><span class="line">| 1000004 |    4 |  123 |</span><br><span class="line">| 1000005 |    4 |  123 |</span><br><span class="line">| 1000006 |    4 |  123 |</span><br><span class="line">| 1000007 |    4 |  123 |</span><br><span class="line">| 1000008 |    4 |  123 |</span><br><span class="line">| 1000009 |    4 |  123 |</span><br><span class="line">| 1000010 |    4 |  123 |</span><br><span class="line">+<span class="comment">---------+------+------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.16</span> sec)</span><br></pre></td></tr></table></figure>
<p>这两种方法的效率相差巨大，那么为什么会如此呢？MySQL是如何执行相差巨大的两条语句的呢？</p>
<h3 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h3><p>根据高性能MySQL中关于limit的说明：<br>limit语句在偏移量巨大时，如<code>select * from t213 where a=4 limit 1000000,10;</code>。<br>对效率的影响主要在于MySQL会查询1,000,010条数据，并取最后10条，抛弃掉前面的1,000,000条。</p>
<p>也就是说，MySQL耗时耗力找到的数据，绝大部分都得废弃！<br>MySQL查找索引a的二级索引树，然后根据二级索引树上的主键值回表到聚簇索引树上进行扫描数据，为了limit而重复大量无用的IO操作<br><img src="limit-1.jpg" alt="1"><br>上图为扫描索引树</p>
<p>关于MySQL为什么limit时会遍历这么多数据，而不是遍历所需的几条，我们不去深究其设计原理，我们只分析下：<br><code>select c1.id, c1.a, c1.b from t213 c1 right join(select id from t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</code><br>语句为何会比<br><code>select * from t213 where a=4 limit 1000000,10;</code><br>快那么多。</p>
<p>我们知道，MySQL中查询的数据会放在数据页中以便快速获取，<br>而系统表information_schema.innodb_buffer_page保存着InnoDB缓冲池中每个页面的信息。</p>
<p>我们在执行sql后查询innodb_buffer_page表中数据页的个数来判断下两个sql语句的不同之处。</p>
<p>** t213表中有近200万数据 **<br>首先，重启MySQL服务，以便innodb_buffer_page表中t213测试表的数据页为空，然后执行不优化的sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select index_name,count(*) from information_schema.innodb_buffer_page</span><br><span class="line">    -&gt; where index_name in('a','primary') and table_name like '%t213%' group by index_name;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.07</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> test.t213 <span class="keyword">where</span> a=<span class="number">4</span> <span class="keyword">limit</span> <span class="number">1000000</span>,<span class="number">10</span>;</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| id      | a | b   |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| 1000001 | 4 | 123 |</span><br><span class="line">| 1000002 | 4 | 123 |</span><br><span class="line">| 1000003 | 4 | 123 |</span><br><span class="line">| 1000004 | 4 | 123 |</span><br><span class="line">| 1000005 | 4 | 123 |</span><br><span class="line">| 1000006 | 4 | 123 |</span><br><span class="line">| 1000007 | 4 | 123 |</span><br><span class="line">| 1000008 | 4 | 123 |</span><br><span class="line">| 1000009 | 4 | 123 |</span><br><span class="line">| 1000010 | 4 | 123 |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">3.29</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> index_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> information_schema.innodb_buffer_page </span><br><span class="line">    -&gt; <span class="keyword">where</span> index_name <span class="keyword">in</span>(<span class="string">'a'</span>,<span class="string">'primary'</span>) <span class="keyword">and</span> table_name <span class="keyword">like</span> <span class="string">'%t213%'</span> <span class="keyword">group</span> <span class="keyword">by</span> index_name;</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| index_name | count(*) |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| a          |      901 |</span><br><span class="line">| PRIMARY    |     2156 |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure>
<p>可以看到<code>select * from test.t213 where a=4 limit 1000000,10;</code>语句使用到901个二级索引a的索引数据页，使用到2156个聚簇索引数据页。</p>
<p>然后我们再次重启MySQL服务，确保innodb_buffer_page是空的，并执行优化的sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select index_name,count(*) from information_schema.innodb_buffer_page</span><br><span class="line">    -&gt; where index_name in('a','primary') and table_name like '%t213%' group by index_name;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> test.t213 c1 <span class="keyword">right</span> <span class="keyword">join</span>(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> test.t213 <span class="keyword">where</span> a=<span class="number">4</span> <span class="keyword">limit</span> <span class="number">1000000</span>,<span class="number">10</span>)c2 <span class="keyword">on</span> c1.id=c2.id;</span><br><span class="line">+<span class="comment">---------+------+------+---------+</span></span><br><span class="line">| id      | a    | b    | id      |</span><br><span class="line">+<span class="comment">---------+------+------+---------+</span></span><br><span class="line">| 1000001 |    4 |  123 | 1000001 |</span><br><span class="line">| 1000002 |    4 |  123 | 1000002 |</span><br><span class="line">| 1000003 |    4 |  123 | 1000003 |</span><br><span class="line">| 1000004 |    4 |  123 | 1000004 |</span><br><span class="line">| 1000005 |    4 |  123 | 1000005 |</span><br><span class="line">| 1000006 |    4 |  123 | 1000006 |</span><br><span class="line">| 1000007 |    4 |  123 | 1000007 |</span><br><span class="line">| 1000008 |    4 |  123 | 1000008 |</span><br><span class="line">| 1000009 |    4 |  123 | 1000009 |</span><br><span class="line">| 1000010 |    4 |  123 | 1000010 |</span><br><span class="line">+<span class="comment">---------+------+------+---------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.22</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> index_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> information_schema.innodb_buffer_page</span><br><span class="line">    -&gt; <span class="keyword">where</span> index_name <span class="keyword">in</span>(<span class="string">'a'</span>,<span class="string">'primary'</span>) <span class="keyword">and</span> table_name <span class="keyword">like</span> <span class="string">'%t213%'</span> <span class="keyword">group</span> <span class="keyword">by</span> index_name;</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| index_name | count(*) |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| a          |      901 |</span><br><span class="line">| PRIMARY    |        3 |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure>
<p>以上可以看到优化后的sql使用了聚簇索引树的3个数据页。</p>
<p>通过两个对比，我们可以发现，在<br><code>select * from test.t213 c1 right join(select id from test.t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</code><br>语句中，首先执行关联语句 <code>select id from test.t213 where a=4 limit 1000000,10</code><br>使用到覆盖索引的概念，扫描二级索引树并获取到主键id值。<br>之后执行外部sql时，由于id已经找到，直接回表聚簇索引树查找响应id数据即可。</p>
<p>而执行未优化的<code>select * from test.t213 where a=4 limit 1000000,10;</code>语句时，<br>每一次在二级索引获取到的id值都需要回表，执行到最后才判断哪些数据是满足条件的，这样导致费力不讨好，效率很慢。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>高性能MySQL中提供有以下几种limit分页的优化方式：<br>1、join关联方式：<code>select * from test.t213 c1 right join(select id from test.t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</code><br>2、主键递增的表，每次分页记录上次的最大id值，下次分页查询通过判断id &gt; last_id_num来执行：<code>select * from test.t213 where id&gt;1000000 and a=4 limit 10;</code><br>3、主键递增的表，通过between id值来执行分页：<code>select * from test.t213 where a=4 and id between 1000001 and 1000010;</code><br>一般来说2，3两种方法虽然效率更高，但是局限性稍大。</p>
<p>实际项目中，针对分页我们要注意，随着数据量的增加，如果limit使用不当，分页效率会越来越慢，导致接口响应时间增加，用户友好度下降。<br>编写sql时使用合适的limit方式，会减少很多不必要的问题。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/14/hello-world/</url>
    <content><![CDATA[<p>今天搞了半天，搞了个博客页面，用它来记录一些自己的东西。</p>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>1: <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">主题</a><br>2: <a href="https://blog.csdn.net/qq_36759224/article/details/82121420" target="_blank" rel="noopener">设置教程1</a><br>3: <a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">设置教程2</a><br>4: <a href="https://www.cnblogs.com/zhangxiaochn/p/Hexo_Theme_Next.html" target="_blank" rel="noopener">设置教程3</a></p>
<h3 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo</span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<h3 id="推送github"><a href="#推送github" class="headerlink" title="推送github"></a>推送github</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
</search>
