<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis数据结构之跳跃表</title>
    <url>/2020/06/30/redis-skiplist/</url>
    <content><![CDATA[<blockquote>
<p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。-《Redis设计与实现》</p>
</blockquote>
<h3 id="一、从链表说起"><a href="#一、从链表说起" class="headerlink" title="一、从链表说起"></a>一、从链表说起</h3><p><img src="list-1.png" alt="1"><br>如上图所示，为一个有序单链表，当要查询某个节点数据时，只能从头到尾遍历获取，查询效率不高。</p>
<p>为了解决单链表的查询效率问题，我们考虑通过在单链表的基础上增加索引的方式来提高查询效率。<br><img src="list-2.png" alt="2"><br>如上图所示，在单链表之上创建索引后，当要查询某个节点时，就可以通过从上而下，从左到右的索引去搜索，有些类似于二分查找。<br>例如查询节点9的信息时，查询路径为：<br><img src="list-3.png" alt="3"></p>
<p>上图我们的单链表索引只有2层，当数据量巨大时，增加多层索引，就可以极大提升效率，而这种在单链表增加多层索引的链表结构就是跳跃表。</p>
<h3 id="二、Redis的跳跃表"><a href="#二、Redis的跳跃表" class="headerlink" title="二、Redis的跳跃表"></a>二、Redis的跳跃表</h3><p>在大部分情况下，跳跃表的效率可以和平衡树相媲美，且跳跃表的实现比平衡树更为简单。<br>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。<br>Redis的跳跃表由zskiplistNode和zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，zskiplist结构用于保存跳跃表节点的相关信息。<br><img src="redis-skiplist.jpg" alt="4"><br>如上图，最左侧为zskiplist结构，包含以下属性：<br>1、header：指向跳跃表头节点<br>2、tail：指向跳跃表尾节点<br>3、level：记录节点做大层高（不包含头节点）<br>4、length：存储跳跃表节点数（不包含头节点）<br>在zskiplist结构右边的4个节点则为zskiplistNode结构，包含以下属性<br>1、层level：图示的L1，L2等标记各个层，层上带前进指针和跨度，前进指针用于访问其他节点，跨度标记距离其他节点的距离。<br>2、后退指针BW：指向当前节点的前一个相邻接点，用于倒序遍历使用<br>3、分值score：图示的1.0，2.0等数值即节点保存的分值，在跳跃表中，节点按各自所保存的分值从小到大排序<br>4、成员对象obj：图示的o1，o2等表示节点所保存的成员对象<br>需要注意的是，表头节点和其他节点的构造是完全一样的，但是表头节点的后退指针，分值和成员对象不会使用。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>在Redis中，跳跃表相关的重点有：<br>1、跳跃表是有序集合的底层实现之一<br>2、Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（表头节点，表尾节点，长度），而zskiplistNode则用于表示跳跃表节点<br>3、每个跳跃表都是1-32之间的随机数<br>4、在同一个跳跃表中，多个节点可以包含同一个分值，但是每个节点的obj是唯一的<br>5、跳跃表中的节点按照分值大小进行排序，分值相同时，按obj大小排序</p>
<p>最后，附上用PHP代码实现的单链表和跳跃表的代码：<br>单链表PHP代码实现：<a href="https://gitee.com/deverz/dev_code/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/SingleList.php" target="_blank" rel="noopener">gitee地址</a><br>跳跃表PHP代码实现：<a href="https://gitee.com/deverz/dev_code/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/SkipList.php" target="_blank" rel="noopener">gitee地址</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL中慢sql问题排查记录</title>
    <url>/2020/06/08/mysql-slow-sql/</url>
    <content><![CDATA[<p>最近线上报警提示一个update操作出现慢sql[2秒左右]，所以对该sql进行分析解决问题：<br>sql语句为：<code>UPDATE test_order SET nstate = 5 WHERE (nstate = 2 and stime &lt; 1589355360)</code></p>
<h3 id="一、实验环境"><a href="#一、实验环境" class="headerlink" title="一、实验环境"></a>一、实验环境</h3><ul>
<li><p>1、MySQL版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| version() |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 8.0.18    |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、实验表建表语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test_order`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`type`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`cid`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`gid`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`isp`</span> <span class="built_in">tinyint</span>(<span class="number">3</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`isv`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`uid`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'用户UID'</span>,</span><br><span class="line">  <span class="string">`ordersn`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">1200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`aid`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`price`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`tprice`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`cprice`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`couid`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`inteid`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`postage`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`intro`</span> <span class="built_in">varchar</span>(<span class="number">120</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`state`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`isold`</span> <span class="built_in">tinyint</span>(<span class="number">3</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`ptime`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`ptype`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`paysn`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`restate`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`issend`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`stime`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`extra`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`ip`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`srcid`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`isvo`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`utime`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  <span class="string">`ctime`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`ise`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`isch`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`pins`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`trsn`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`channel`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`ntype`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`nissend`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`nstate`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`ispay`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`scores`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`ispush`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`supid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`specid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  <span class="string">`class`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'xx'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ordersn_unique`</span> (<span class="string">`ordersn`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`uid`</span> (<span class="string">`uid`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`ctime_index`</span> (<span class="string">`ctime`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'订单表'</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h3><p>一般分析我们遇到的一些慢sql都和索引不合理有关，但是在处理具体问题时，应该根据具体情况具体对待，并不是说你加个索引就ok了。<br>你需要分析业务，分析表数据，然后制定合理的索引去处理问题。要知道，在线上业务，牵一发而动全身，一定要慎之又慎。<br>1、表数据<br>拿到这个报警时，首先我去线上只读备库查询表数据，查到线上表数据大概有157万条，也不算少了。<br>然后，查看该表结构，看到对stime字段和nstate字段并未建立相关索引，此时可以基本确定，update时由于未使用到索引而进行了全表扫描导致慢查询了。<br>2、业务代码<br>这个时候，还是不能着急的去创建索引，我们应该去业务代码查看具体业务问题。<br>找到相应的业务代码，发现在业务上是一个定时脚本在跑订单状态数据，以更新相应订单状态。<br>经过分析，对该业务进行相应的优化，对于mysql的update操作将会更加的合理。<br>将该业务由stime&lt;xxx 改为 stime<xxx and stime>xxx 即：由时间点前全取，改为时间段内取，每次取当前时间前40分钟内的数据。<br>并将脚本执行频率改为半小时执行一次，这样就保证业务的准确性，也保证了每次update不会更新大量数据，出现长时间锁表问题。<br>3、索引<br>分析完业务，此时就要真正的去关心索引问题了。将update语句改为相应的select结构语句为：<br><code>select * from test_order  WHERE nstate = 2 and stime &gt;= 1577664001 and stime &lt; 1577665001</code><br>优化分为两种：<br>a、单索引<br>b、组合索引<br>我们知道，MySQL中的索引也是一个一个的B+树，虽然索引能极大的提升查询效率，但是每次的更新插入操作，在MySQL底层还需要维护索引树的相应更新，这是耗时耗力的。<br>所以对业务以及数据量进行分析，能建立单索引解决问题的，我们就不必要建立组合索引了。<br>对业务来说，是一个脚本更新状态的操作，所以业务相对简单，接下来就根据数据量进行一些实验，以验证索引的创建对性能的影响大小。</p>
<h3 id="三、实验开始"><a href="#三、实验开始" class="headerlink" title="三、实验开始"></a>三、实验开始</h3><p>1、数据量为50万左右</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(*) from test_order;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|   514147 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.11</span> sec)</span><br></pre></td></tr></table></figure>
<p>无索引时进行explain：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from test_order  WHERE nstate = 2 and stime &gt;= 1577664001 and stime &lt; 1577665001;</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line">| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | test_order | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 493543 |     1.11 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询耗时：</span></span><br><span class="line"><span class="number">991</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.87</span> sec)</span><br></pre></td></tr></table></figure>

<p>创建nsate单索引，并explain：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE `test_order` ADD INDEX `idx_nstate`(`nstate`) USING BTREE;</span><br><span class="line">Query OK, 0 rows affected (0.91 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from test_order  WHERE nstate = 2 and stime &gt;= 1577664001 and stime &lt; 1577665001;</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+------+---------------+------------+---------+-------+--------+----------+-------------+</span></span><br><span class="line">| id | select_type | table    | partitions | type | possible_keys | key        | key_len | ref   | rows   | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+------+---------------+------------+---------+-------+--------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | test_order | NULL       | ref  | idx_nstate    | idx_nstate | 1       | const | 127872 |    11.11 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+------+---------------+------------+---------+-------+--------+----------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询耗时：</span></span><br><span class="line"><span class="number">991</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.57</span> sec)</span><br></pre></td></tr></table></figure>

<p>创建stime单索引，并explain：【此时删除掉nstate单索引】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE `test_order` ADD INDEX `idx_stime`(`stime`) USING BTREE;</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from test_order  WHERE nstate = 2 and stime &gt;= 1577664001 and stime &lt; 1577665001;</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------------------------------+</span></span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                                         |</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | test_order | NULL       | range | idx_stime     | idx_stime | 4       | NULL | 5967 |    10.00 | Using index condition; Using where; Using MRR |</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询耗时：</span></span><br><span class="line"><span class="number">991</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure>

<p>创建stime_nstate组合索引，并explain：【删除掉nstaet和stime单索引】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE `test_order` ADD INDEX `idx_stime`(`stime`) USING BTREE;</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from test_order  WHERE nstate = 2 and stime &gt;= 1577664001 and stime &lt; 1577665001;</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+-------+------------------+------------------+---------+------+------+----------+----------------------------------+</span></span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                            |</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+-------+------------------+------------------+---------+------+------+----------+----------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | test_order | NULL       | range | idx_stime_nstate | idx_stime_nstate | 5       | NULL | 5967 |    10.00 | Using index condition; Using MRR |</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+-------+------------------+------------------+---------+------+------+----------+----------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询耗时：</span></span><br><span class="line"><span class="number">991</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>分析：<br>1、naste不适合单独创建索引，因为他的离散度太小，建立索引意义不大，很容易导致全表扫描。<br>2、stime离散度很好，建立单索引能有效提升查询效率。<br>3、stime_nstate组合索引效率最高，比单stime效率能提升大概3-4倍查询效率。</p>
<p>额外说下Extra列中出现的Using MRR：<br>MRR全称为：Multi-Range Read【组合范围读】<br>这是MySQL对回表查询的一种优化方式，简单来说就是将二级索引中查到的主键进行排序，然后到聚簇索引上进行顺序读，也就是说将随机IO变为顺序IO，这样会极大的提高查询效率。</p>
<p>再额外说下key_len列中的数字：<br>看下字段设置：<br>nstate为tinyint不为null，占1字节<br>stime为int不为null，占4字节<br>其中tinyint和int如果允许为null，则会额外加1字节。<br>key_len对组合索引的使用情况有很大的参考意义。</p>
<p>接下来继续增加表数据量为100万，160万，220万进行相应的测试：<br>结果显示<br>无索引的情况下，where查询越来越慢；<br>nstate单索引，where查询效率虽有提升，但提升不大，每次扫描的行数据相当大；<br>stime单索引，where查询效率稳定在0.03秒左右<br>stime_nstate组合索引，where查询效率稳定在0.01秒左右</p>
<p>当然了，测试的数据量不够多，但是可以简单的得出一个结论就是：<br>stime单索引和stime_nstate组合索引效率提升明显，且组合索引是单索引效率的3倍左右。</p>
<p>最终我选择了建立单stime索引。单索引已经可以提升效率，且业务中只在定时脚本使用该索引，而且该表结构比较复杂，已有一些索引结构，不再建立组合索引影响更新删除。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>总的来说，优化一条sql语句需要考虑数据量，具体业务以及具体表结构。<br>需要注意的一点是，建立索引要充分考虑字段的离散度，建立组合索引要把离散度高的尽量放在前面。<br>对于业务来说，也可能要配合进行相应的调整以便更好的执行sql语句。<br>当然了，这个处理还是比较简单的一个sql，没有很大的参考性，就记录下来供大家看看吧。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL的字段默认null对唯一索引的影响</title>
    <url>/2020/04/23/mysql-unique/</url>
    <content><![CDATA[<p>在日常业务开发中，会经常遇到需要保证唯一性的数据业务，如用户注册业务。<br>一般注册业务中允许用户以手机号或email注册账号，且需要保证唯一，不允许重复注册。当用户输入手机号或email登录时，程序会判定输入信息的存在与否性，存在则走登录，不存在则走注册。<br>而保证唯一性就不仅仅需要在程序端做判断，还需要MySQL的唯一索引去做最后一道防线。</p>
<p>在阿里的《阿里巴巴Java开发手册》中关于MySQL-索引规范中写道：<br>【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须创建唯一索引。<br>说明：不要以为唯一索引影响了insert速度，这个速度的损耗可以忽略不计，但提高查找的速度是明显的；另外，<br>即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p>
<p>此篇文章旨在讨论索引字段默认值为null时，对唯一索引的影响。</p>
<h3 id="一、简单描述下为何唯一索引为影响insert速度"><a href="#一、简单描述下为何唯一索引为影响insert速度" class="headerlink" title="一、简单描述下为何唯一索引为影响insert速度"></a>一、简单描述下为何唯一索引为影响insert速度</h3><p>在MySQL中，唯一索引树是一个非聚簇索引，每次插入数据时，都会在唯一索引树上进行遍历查找该插入值是否唯一，<br>这也就是为什么会影响insert的速度，因为多一步遍历判断唯一性。</p>
<h3 id="二、做个试验验证字段默认值为null时的影响"><a href="#二、做个试验验证字段默认值为null时的影响" class="headerlink" title="二、做个试验验证字段默认值为null时的影响"></a>二、做个试验验证字段默认值为null时的影响</h3><p>1、MySQL版本：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| version() |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 8.0.18    |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>2、假设只存在邮箱注册：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'邮箱'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'名字'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uk-email`</span> (<span class="string">`email`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
<p>insert数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一次插入：</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(email,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="string">'aaa@qq.com'</span>,<span class="string">'aaa'</span>);</span><br><span class="line">Affected rows: 1, Time: 0.003000s</span><br><span class="line"></span><br><span class="line"><span class="comment">#再次插入同样的数据：</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(email,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="string">'aaa@qq.com'</span>,<span class="string">'aaa'</span>);</span><br><span class="line">1062 - Duplicate entry 'aaa@qq.com' for key 'uk-email', Time: 0.005000s</span><br></pre></td></tr></table></figure>
<p>此时对于唯一性来说是没问题的，可以保证业务的email的唯一性。<br>假设随着业务的发展，此时需要增加手机号注册功能，那么表中就需要增加手机号字段，且需要保证手机号和邮箱的关联唯一性<br>建一个新表来演示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建表语句，注意此时phone字段的默认值为null</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_2`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'邮箱'</span>,</span><br><span class="line">  <span class="string">`phone`</span> <span class="built_in">char</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'手机号'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'名字'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uk-email-phone`</span> (<span class="string">`email`</span>,<span class="string">`phone`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
<p>insert数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_2(email,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="string">'aaa@qq.com'</span>,<span class="string">'aaa'</span>);</span><br><span class="line">Affected rows: 1, Time: 0.003000s</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_2(email,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="string">'aaa@qq.com'</span>,<span class="string">'aaa'</span>);</span><br><span class="line">Affected rows: 1, Time: 0.003000s</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_2(email,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="string">'aaa@qq.com'</span>,<span class="string">'aaa'</span>);</span><br><span class="line">Affected rows: 1, Time: 0.003000s</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_2(email,phone,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="string">'bbb@qq.com'</span>,<span class="string">'13333333333'</span>,<span class="string">'bbb'</span>);</span><br><span class="line">Affected rows: 1, Time: 0.003000s</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_2(email,phone,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="string">'bbb@qq.com'</span>,<span class="string">'13333333333'</span>,<span class="string">'bbb'</span>);</span><br><span class="line">1062 - Duplicate entry 'bbb@qq.com-13333333333' for key 'uk-email-phone', Time: 0.002000s</span><br></pre></td></tr></table></figure>
<p>此时会发现，不带phone值得前三条数据都能插入成功，带上邮箱和手机号的值却能正常判断唯一性</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from user_2;</span><br><span class="line">+<span class="comment">----+------------+-------------+------+</span></span><br><span class="line">| id | email      | phone       | name |</span><br><span class="line">+<span class="comment">----+------------+-------------+------+</span></span><br><span class="line">|  1 | aaa@qq.com | NULL        | aaa  |</span><br><span class="line">|  2 | aaa@qq.com | NULL        | aaa  |</span><br><span class="line">|  3 | aaa@qq.com | NULL        | aaa  |</span><br><span class="line">|  4 | bbb@qq.com | 13333333333 | bbb  |</span><br><span class="line">+<span class="comment">----+------------+-------------+------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>这时就需要牵扯到MySQL的唯一索引机制了：<br>在MySQL官方文档中<a href="https://dev.mysql.com/doc/refman/5.7/en/create-index.html#create-index-unique" target="_blank" rel="noopener">MySQL索引文档</a>，描述到：<br>A UNIQUE index creates a constraint such that all values in the index must be distinct.<br>An error occurs if you try to add a new row with a key value that matches an existing row.<br>If you specify a prefix value for a column in a UNIQUE index, the column values must be unique within the prefix length.<br>A UNIQUE index permits multiple NULL values for columns that can contain NULL.<br>翻译：<br>唯一索引创建一个约束，使得索引中的所有值都必须是不同的。<br>如果尝试添加一个键值与现有行匹配的新行，则会发生错误。<br>如果在唯一索引中为列指定前缀值，则列值在前缀长度内必须是唯一的。<br>唯一索引允许包含空值的列有多个空值。</p>
<p>先看下explain执行计划：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from user_2 where email='aaa@qq.com' and phone is NULL;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+----------------+----------------+---------+-------------+------+----------+-----------------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys  | key            | key_len | ref         | rows | filtered | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+----------------+----------------+---------+-------------+------+----------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user_2 | NULL       | ref  | uk-email-phone | uk-email-phone | 132     | const,const |    3 |   100.00 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+----------------+----------------+---------+-------------+------+----------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> user_2 <span class="keyword">where</span> email=<span class="string">'bbb@qq.com'</span> <span class="keyword">and</span> phone=<span class="string">'13333333333'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+----------------+----------------+---------+-------------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys  | key            | key_len | ref         | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+----------------+----------------+---------+-------------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | user_2 | NULL       | const | uk-email-phone | uk-email-phone | 132     | const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+----------------+----------------+---------+-------------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>有没有发现一个有趣的现象，虽然两个sql语句都使用到了uk-email-phone唯一索引，但是<br>第一条sql的type为ref<br>第二条sql的type为const<br>我们知道，explain执行计划中，const一般是主键查询或者唯一索引查询是才会出现，而ref一般是使用普通索引时出现。<br>所以，可以得出结论，MySQL在底层对唯一索引的null值做了特殊处理。</p>
<p>通过相关资料查询，找到以下源码可以明确出唯一索引的null值处理：<a href="https://github.com/mysql/mysql-server/blob/8e797a5d6eb3a87f16498edcb7261a75897babae/storage/innobase/row/row0ins.cc" target="_blank" rel="noopener">源码github地址</a><br>在改c文件的1863行，有这么个注释：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Scans <span class="keyword">a</span> unique non-clustered index <span class="keyword">at</span> <span class="keyword">a</span> given index entry <span class="built_in">to</span> determine</span><br><span class="line">whether <span class="keyword">a</span> uniqueness violation has occurred <span class="keyword">for</span> <span class="keyword">the</span> key <span class="built_in">value</span> <span class="keyword">of</span> <span class="keyword">the</span> entry.</span><br><span class="line">Set shared locks <span class="keyword">on</span> <span class="title">possible</span> <span class="title">duplicate</span> <span class="title">records</span></span><br><span class="line"></span><br><span class="line">扫描给定索引项处的唯一非聚集索引以确定条目的键值是否发生唯一性冲突。</span><br><span class="line">对可能重复的记录设置共享锁。</span><br></pre></td></tr></table></figure>
<p>也就是说<code>row_ins_scan_sec_index_for_duplicate()</code>该方法就是处理唯一索引的，<br>继续往下看，在1892行，有一串注释：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">If the secondary <span class="keyword">index</span> <span class="keyword">is</span> <span class="keyword">unique</span>, but one of the fields <span class="keyword">in</span> the</span><br><span class="line">n_unique <span class="keyword">first</span> fields <span class="keyword">is</span> <span class="literal">NULL</span>, a <span class="keyword">unique</span> <span class="keyword">key</span> violation cannot occur,</span><br><span class="line">since we define <span class="literal">NULL</span> != <span class="literal">NULL</span> <span class="keyword">in</span> this <span class="keyword">case</span></span><br><span class="line"></span><br><span class="line">如果二级索引是唯一的，但是唯一索引的字段存在<span class="literal">NULL</span>，则不会发生唯一性冲突，在此代码中定义了<span class="literal">NULL</span> != <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<p>继续往下走，在1996行，走到了<code>row_ins_dupl_error_with_rec()</code>函数，该函数在1825行。<br>在该函数中有以下代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* In a unique secondary index we allow equal key values if they</span></span><br><span class="line"><span class="comment">  contain SQL NULLs </span></span><br><span class="line"><span class="comment">   在唯一的二级索引中，如果包含sql NULL值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">if</span> (!index-&gt;is<span class="constructor">_clustered()</span><span class="operator"> &amp;&amp; </span>!index-&gt;nulls_equal) &#123;</span><br><span class="line">    for (i = <span class="number">0</span>; i &lt; n_unique; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dfield<span class="constructor">_is_null(<span class="params">dtuple_get_nth_field</span>(<span class="params">entry</span>, <span class="params">i</span>)</span>)) &#123;</span><br><span class="line">        return (FALSE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，在唯一索引中字段为NULL的情况下，返回false，没有抛出DB_DUPLICATE_KEY异常</p>
<p>ps：c代码看起来很吃力，半看半猜，这也是查到的相关文档找到的相关代码，可能解释的并不对，望不吝赐教。得恶补c知识了。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>唯一索引重复插入之终极解决方案：给字段设置空字符串初始值，<code>NOT NULL DEFAULT &#39;&#39;</code>即可，不要用null值作为初始值。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>为何MySQL使用B+树，MongoDB使用B树</title>
    <url>/2020/04/22/mysqlb-monb/</url>
    <content><![CDATA[<p>今天在网上看到一篇很有意思的关于B+树和B树的探讨，值得收藏，所以写下此篇文章。<br>网上有些文章会写到B树不适合做文件存储系统的索引结构，那么它真的那么不堪吗？</p>
<h3 id="一、B树和B-树的结构与特点"><a href="#一、B树和B-树的结构与特点" class="headerlink" title="一、B树和B+树的结构与特点"></a>一、B树和B+树的结构与特点</h3><p>首先，看一下B树和B+树的结构图：<br>B树：<br><img src="btree.png" alt="1"></p>
<p>通过上图可以发现B树的特点为：</p>
<ul>
<li>1、每个节点都存储数据data</li>
<li>2、叶子节点之间无相邻指针关联</li>
</ul>
<p>B+树：<br><img src="bptree.png" alt="2"></p>
<p>通过上图对B+树的结构的观察，其特点为：</p>
<ul>
<li>1、数据data只存储在叶子节点上</li>
<li>2、所有叶子节点上都通过指针进行关联</li>
</ul>
<p>所以，综上观察，得出以下结论：<br>1、B树存储结构中，数据存储在各个节点上，在做单一查询时，其查询性能不稳定，最好的情况为O(1)，但是整体来说，单一查询还是B树较为合适。<br>但在B树上做遍历查询时，由于其没有指针对各节点进行关联，所以效率不高，每次遍历都需要从根节点开始查找。<br>2、B+树存储结构中，由于其数据只存储叶子节点上，所以在做单一查询时，查询性能固定，每次都从根节点开始查找，最后查到叶子节点上。<br>但在B+树上做遍历查询时，由于其叶子节点上存在关联指针，所以遍历时不需要回到根节点遍历，只需要对叶子节点进行遍历即可，所以B+树的范围查询效率较高。</p>
<h3 id="二、继续分析"><a href="#二、继续分析" class="headerlink" title="二、继续分析"></a>二、继续分析</h3><p>那么是不是可以这么想：由于MongoDB中主要做单一查询，所以用B树呢？而MySQL遍历查询场景应用比较频繁，所以采用B+树呢？<br>那么问题来了：为什么MySQL中做数据遍历多，而MongoDB中数据遍历少呢？</p>
<p>带着这些疑问，继续往下分析：<br>我们知道，MySQL属于关系型数据库，MongoDB属于非关系型数据库。<br>举个例子：此时，我们有两个逻辑需要建表存储数据，分别为：<br>1、学生信息；2、班级信息。<br>其逻辑关系为：一个班级对应多个学生，一个学生只能有一个班级，即一对多的关系<br>在关系型数据库中分为一对一，一对多，多对多三种关系，其中一对多的关系，使用两张表即可：<br><img src="table.png" alt="3"></p>
<p>此时在查询class_name=’一班’的所有学生时，sql为：【class_name列建立索引】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_student <span class="keyword">where</span> class_id <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> test_class <span class="keyword">where</span> class_name=<span class="string">'一班'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>以上sql就涉及到数据遍历查询的操作。也就是说会到B+树的叶子节点上进行遍历查询。</p>
<p>在非关系型数据库MongoDB中，如果以MySQL设计表的思想去建立数据类型就是：<br><img src="mongo.png" alt="4"><br>以MySQL的思想去设计MongoDB的话，对于MongoDB的B树结构就是一种浪费了。<br>MongoDB之所以使用B树结构，肯定是不希望使用者以关系型数据库的思想去建立数据表结构。<br>所以，考虑B树的结构，在MongoDB中，应该这样创建表：<br><img src="mongo-2.png" alt="5"></p>
<p>此时，查询班级为 “一班” 的查询语句就为：【class_name列建索引】</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.class</span><span class="selector-class">.find</span>( &#123;<span class="attribute">class_name</span>: <span class="string">'一班'</span>&#125; )</span><br></pre></td></tr></table></figure>
<p>这样就是一个单一查询，不需要遍历逐行匹配，最好的情况下，一次就能查到。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>由于关系型数据库和非关系型数据库在设计方式上的不同，导致在关系型数据库中，遍历查询十分普遍，且严格来说B+树的单一查询效率也很均衡，所以采用B+树比较合理。<br>而非关系型数据库中，单一查询十分常见，所以采用B树，相比较B+树来说，虽然效率不均衡，但是总体来说单一查询效率还是比B+树高的。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL中表自增id用完了是否还能插入数据？</title>
    <url>/2020/04/07/mysql-auto-max/</url>
    <content><![CDATA[<p>从未考虑过自增id能用完这个问题，最近看到相关文章，那么我也来做个实验，看看具体情况。</p>
<h3 id="一、实验环境"><a href="#一、实验环境" class="headerlink" title="一、实验环境"></a>一、实验环境</h3><ul>
<li><p>1、MySQL版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| version() |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 8.0.18    |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、实验表建表语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4294967294</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="二、相关内容"><a href="#二、相关内容" class="headerlink" title="二、相关内容"></a>二、相关内容</h3><ul>
<li>1、自增id</li>
</ul>
<p>在MySQL的InnoDB引擎中，一般来说，建表时都建议定义一个自增id作为其主键值，其优点在于：<br>1.自增id的有序递增；<br>2.有序递增的主键使得插入数据时，不会导致数据页分裂次多过多，造成数据页碎片化严重；<br>3.聚簇索引查询时，根据有序递增的顺序查询更快速；<br>4.数据页碎片化不严重，就不会浪费更多的磁盘空间。</p>
<p>实验表中，我设置实验表t默认自增从4294967294开始，这是因为int值占4个字节，其unsigned的取值范围为0~4294967295，可以看下正常插入数据到顶点时，会出现什么情况。</p>
<h3 id="三、实验开始"><a href="#三、实验开始" class="headerlink" title="三、实验开始"></a>三、实验开始</h3><p>1、插入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t values(null);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t values(null);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| id         |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| 4294967294 |</span><br><span class="line">| 4294967295 |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t values(null);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry '4294967295' for key 'PRIMARY'</span><br></pre></td></tr></table></figure>
<p>可以看到，在插入第二条数据时，id值已经到达了int值的取值范围顶点，此时继续插入数据，则会报错提示：主键重复<br>那么也就可以得出结论：<br><strong>当自增主键用完时，将不能再继续插入新数据。MySQL底层在自增主键取值到达顶点时，依旧使用最大值作为主键值插入，所以会报错为主键重复</strong></p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>实验很简单的做完了，也得出了疑问中的结论。<br>MySQL中表自增id用完了，就无法继续成功插入新数据，所以说在生产上，应尽量考虑到这种情况，以免生产环境出现问题时手忙脚乱。<br>但是，一般来说int unsigned在业务中是足够用的，不需要考虑的太多，如果真的不够用了，那么可以用bigint unsigned（8个字节）来作为自增主键值。</p>
<p>还有一种情况是，当表未指定主键id时：<br>当MySQL InnoDB数据表未指定主键id时，InnoDB会自动给该表创建一个不可见序列值（记为row_id）作为该表的主键id。<br>需要注意的是，InnoDB在全局中维护了一个dictsys.row_id，所有未定义主键的表共用该row_id配置，<br>也就是说，每插入一条数据都将row_id作为主键，然后将全局row_id +1，然后其他表继续使用。</p>
<p>该row_id长度为6字节，使用bigint unsigned类型（使用了该类型，却只用6字节的数据），<br>这样就会存在一个问题：row_id递增到 <code>2的48次方减1</code> 时row_id再加1就会变为0，存在风险。<br>而且，前面介绍了主键逐个递增的好处，所以说，最好的方法还是定义一个主键，而不是使用InnoDB创建的自动主键。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL中join关联查询是如何执行的？</title>
    <url>/2020/02/29/mysql-join/</url>
    <content><![CDATA[<p>在上一篇文章&lt;MySQL中如何更好的使用Limit？&gt;中，我们最后写到limit优化的方式之一就是用到了join关联查询，那么多表的关联查询是如何执行的呢？<br>带着这个疑问，我们一起探究下join关联查询的执行步骤！</p>
<h3 id="一、实验环境"><a href="#一、实验环境" class="headerlink" title="一、实验环境"></a>一、实验环境</h3><ul>
<li><p>1、MySQL版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| version() |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 8.0.18    |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、实验表结构 t1数据100条，t2数据1000条</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc t1;</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| id    | int(11) | NO   | PRI | NULL    |       |</span><br><span class="line">| a     | int(11) | YES  | MUL | NULL    |       |</span><br><span class="line">| b     | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t1;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|      100 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">desc</span> t2;</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| id    | int(11) | NO   | PRI | NULL    |       |</span><br><span class="line">| a     | int(11) | YES  | MUL | NULL    |       |</span><br><span class="line">| b     | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t2;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|     1000 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="二、驱动表"><a href="#二、驱动表" class="headerlink" title="二、驱动表"></a>二、驱动表</h3><ul>
<li>1、驱动表的概念</li>
</ul>
<p>提到join，就不得不说到驱动表。<br>驱动表：在关联查询中首先执行的表，叫做驱动表。在使用join时，默认会有MySQL的优化器去选择合适表作为驱动表。</p>
<p>在join语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。</p>
<p>执行以下sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 join t2 on t1.a=t2.a;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref       | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | a             | NULL | NULL    | NULL      |  100 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ref  | a             | a    | 5       | test.t1.a |    1 |   100.00 | NULL        |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>在 explain 中，第一行的表就是驱动表。可以看出，上面的sql语句的驱动表为t1表。<br>根据row字段信息，可以看出，t1表进行了全表扫描，t2表使用了字段a上的索引。</p>
<ul>
<li>2、如何选取驱动表</li>
</ul>
<p><em>a. MySQL自动选取</em></p>
<p>一般来说，MySQL会选取小表作为驱动表，注意，这里的小表不是总数据量少的那张表，而是根据sql中的表过滤条件去决定的。</p>
<p>执行以下sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sql1</span></span><br><span class="line">mysql&gt; explain select * from t1 join t2 on t2.b=t1.b;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  100 |   100.00 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1000 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sql2</span></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> t2.b=t1.b <span class="keyword">where</span> t2.id&lt;<span class="number">50</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   49 |   100.00 | Using where                                        |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |  100 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>以上实验可以看出：</p>
<p>sql1的驱动表为t1表，因为在没有其他过滤条件的情况下，t1表只有100条数据，优先以小表作为驱动表。<br>sql2的驱动表为t2表，因为where条件中的 <code>t2.id&lt;50</code> 使得t2表过滤之后只有49条数据，所以t2表是小表。</p>
<p><em>b. 手动选取</em></p>
<p>使用 straight_join 代替 join 其将强制选取第一张表作为驱动表。<br>执行下上面的sql2，将join换为straight_join。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 straight_join t2 on t2.b=t1.b where t2.id&lt;50;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |  100 |   100.00 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   49 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="三、关联查询算法"><a href="#三、关联查询算法" class="headerlink" title="三、关联查询算法"></a>三、关联查询算法</h3><p>MySQL中join关联查询共有四种查询算法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Simple Nested-Loop join,</span><br><span class="line">Block Nested-Loop join,</span><br><span class="line">Index Nested-Loop join，</span><br><span class="line">Batched Key Access join</span><br></pre></td></tr></table></figure>
<p>在使用索引关联的情况下，有Index Nested-Loop join和Batched Key Access join两种算法；<br>在不使用索引关联的情况下，有Simple Nested-Loop join和Block Nested-Loop join两种算法。</p>
<ul>
<li>1、索引关联情况（t1,t2表的a字段有索引)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 join t2 on t2.a=t1.a where t2.id&lt;50;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref       | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY,a     | PRIMARY | 4       | NULL      |   49 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref   | a             | a       | 5       | test.t2.a |    1 |   100.00 | NULL        |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>执行步骤为：<br>1、MySQL优化器根据过滤条件得出驱动表为t2；<br>2、根据 <code>t2.id&lt;50，t2.*</code> 查询到一行t2.id=1的数据，拿到t2.a的值和t1.a做关联；<br>3、搜寻t1.a索引树，找到t1.id，回表查询t1.*数据；<br>4、组成整体数据行，放入结果集中；<br>5、循环1-4步骤，直到取完数据。</p>
<p>执行过程图：<br><img src="join-index.jpg" alt="1"></p>
<p>以上流程就是Index Nested-Loop join算法（索引嵌套循环连接）的执行过程，可以发现，如果在被驱动表(t.1)的索引树上不存在需要查询的所有字段，则需要回表到聚簇索引上查询，<br>每次回表都是一次随机查询，对于MySQL来说，性能并不是很好。</p>
<p>因此，MySQL在5.6引入了Batched Key Access join算法（成批密钥访问连接）。<br>针对上面的Index Nested-Loop join算法实例，该算法的执行逻辑为：<br>1、MySQL优化器根据过滤条件得出驱动表为t2；<br>2、根据 <code>t2.id&lt;50，t2.*</code> 查询到一行t2.id=1的数据；<br>3、将第2步的行数据放到join_buffer中，循环第二步，直到join_buffer放满；<br>4、根据join_buffer中的t2.a的值和t1.a做关联，搜寻t1.a索引树，找到t1.id；<br>5、将第3步的索引数据放到read_rnd_buffer中，并将read_rnd_buffer中的t1.id排序；<br>6、循环3~4步骤，直到read_rnd_buffer放满；<br>7、通过MRR(Multi-Range Read)将read_rnd_buffer中的数据进行回表查询；<br>8、将回表的查询结果和join_buffer中的数据组合成整体数据行，放入结果集中。</p>
<p>执行过程图：<br><img src="join-bka.jpg" alt="2"></p>
<p>在以上Batched Key Access join算法执行步骤中，其优化了两点：<br>1、驱动表查询到的行数据先缓存在join_buffer中，之后批量访问被驱动表索引树；<br>2、被驱动表索引行数据缓存在read_rnd_buffer中并按照主键进行排序，之后MRR顺序回表查询数据。<br>Batched Key Access join算法避免了多次访问被驱动表索引树，并将随机回表变为顺序回表，大大提升了查询效率。</p>
<ul>
<li>2、无索引关联情况（t1,t2表的b字段无索引）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 join t2 on t2.b=t1.b where t2.id&lt;50;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   49 |   100.00 | Using where                                        |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |  100 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>根据explain sql执行计划，我们在Extra字段中可以看到，其使用到了Block Nested-Loop join算法（块嵌套循环连接）。<br>Block Nested-Loop join算法和Batched Key Access join算法执行步骤类似，只是没有read_rnd_buffer。</p>
<p>其执行步骤为：<br>1、MySQL优化器根据过滤条件得出驱动表为t1；<br>2、根据 <code>t2.id&lt;50，t2.*</code> 查询到一行t2.id=1的数据；<br>3、将第2步的行数据放到join_buffer中，循环第二步，直到join_buffer放满；<br>4、根据join_buffer中的t2.b的值和t1.b做关联，全表扫描t1，批量取出行数据；<br>5、将全表扫描查询结果和join_buffer中的数据组合成整体数据行，放入结果集中。</p>
<p>执行过程图：<br><img src="join-bnl.jpg" alt="3"></p>
<p>关于Simple Nested-Loop join算法，MySQL已经不再使用，其执行步骤为Block Nested-Loop join算法执行步骤中去掉join_buffer内容。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>此篇文章我们介绍了join关联查询下，驱动表的概念以及四种关联查询算法。</p>
<p>Batched Key Access join算法（BKA）是最优的join优化解决方案，使用BKA可以大大的提高sql的执行效率。<br>在MySQL中Batched Key Access join算法默认并未开启，需要在执行sql前启用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动BKA &amp; MMR</span></span><br><span class="line">mysql&gt; set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select t1.*,t2.* from t1 join t2 on t2.a=t1.a where t2.id&lt;80;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+----------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref       | rows | filtered | Extra                                  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+----------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY,a     | PRIMARY | 4       | NULL      |   79 |   100.00 | Using where                            |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref   | a             | a       | 5       | test.t2.a |    1 |   100.00 | Using join buffer (Batched Key Access) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+----------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>关联查询在无索引关联时，对被驱动表的全表扫描十分浪费资源，所以在平时我们编写关联sql查询时，在数据表中有大量数据时，应尽量避免无索引关联的情况，on后的语句中的关联条件应为其建立必要的索引，实在无法为字段建立索引，则应考虑其他方式进行关联查询。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL中如何更好的使用Limit？</title>
    <url>/2020/02/12/mysql-limit/</url>
    <content><![CDATA[<p>在业务中实现分页功能就离不了MySQL的limit语句，而随着数据表中数据量的增加，则不可避免会导致查询时偏移量过大。<br>我们知道随着偏移量的增大，limit语句的耗时会增加，接下来我们就探讨下如何去更好的处理limit的耗时问题。</p>
<h3 id="一、实验"><a href="#一、实验" class="headerlink" title="一、实验"></a>一、实验</h3><p>1、MySQL版本：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| version() |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 8.0.18    |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>2、实验表结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc t213;</span><br><span class="line">+<span class="comment">-------+------------------+------+-----+---------+----------------+</span></span><br><span class="line">| Field | Type             | Null | Key | Default | Extra          |</span><br><span class="line">+<span class="comment">-------+------------------+------+-----+---------+----------------+</span></span><br><span class="line">| id    | int(10)          | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| a     | int(10) unsigned | NO   | MUL | 0       |                |</span><br><span class="line">| b     | int(10) unsigned | NO   |     | 0       |                |</span><br><span class="line">+<span class="comment">-------+------------------+------+-----+---------+----------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>其中，id为自增主键，字段a为普通索引</p>
<p>3、实验数据量近200万：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(*) from t213;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|  1979311 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.11</span> sec)</span><br></pre></td></tr></table></figure>

<p>4、开始测试：<br>当偏移量为100万时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t213 where a=4 limit 1000000,10;</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| id      | a | b   |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| 1000001 | 4 | 123 |</span><br><span class="line">| 1000002 | 4 | 123 |</span><br><span class="line">| 1000003 | 4 | 123 |</span><br><span class="line">| 1000004 | 4 | 123 |</span><br><span class="line">| 1000005 | 4 | 123 |</span><br><span class="line">| 1000006 | 4 | 123 |</span><br><span class="line">| 1000007 | 4 | 123 |</span><br><span class="line">| 1000008 | 4 | 123 |</span><br><span class="line">| 1000009 | 4 | 123 |</span><br><span class="line">| 1000010 | 4 | 123 |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">2.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>我们知道以上的方法效率并不高，一般我们在数据量大的数据表中，不直接limit，而是通过连接去先查询id，再查询字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select c1.id, c1.a, c1.b from t213 c1 right join(select id from t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</span><br><span class="line">+<span class="comment">---------+------+------+</span></span><br><span class="line">| id      | a    | b    |</span><br><span class="line">+<span class="comment">---------+------+------+</span></span><br><span class="line">| 1000001 |    4 |  123 |</span><br><span class="line">| 1000002 |    4 |  123 |</span><br><span class="line">| 1000003 |    4 |  123 |</span><br><span class="line">| 1000004 |    4 |  123 |</span><br><span class="line">| 1000005 |    4 |  123 |</span><br><span class="line">| 1000006 |    4 |  123 |</span><br><span class="line">| 1000007 |    4 |  123 |</span><br><span class="line">| 1000008 |    4 |  123 |</span><br><span class="line">| 1000009 |    4 |  123 |</span><br><span class="line">| 1000010 |    4 |  123 |</span><br><span class="line">+<span class="comment">---------+------+------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.16</span> sec)</span><br></pre></td></tr></table></figure>
<p>这两种方法的效率相差巨大，那么为什么会如此呢？MySQL是如何执行相差巨大的两条语句的呢？</p>
<h3 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h3><p>根据高性能MySQL中关于limit的说明：<br>limit语句在偏移量巨大时，如<code>select * from t213 where a=4 limit 1000000,10;</code>。<br>对效率的影响主要在于MySQL会查询1,000,010条数据，并取最后10条，抛弃掉前面的1,000,000条。</p>
<p>也就是说，MySQL耗时耗力找到的数据，绝大部分都得废弃！<br>MySQL查找索引a的二级索引树，然后根据二级索引树上的主键值回表到聚簇索引树上进行扫描数据，为了limit而重复大量无用的IO操作<br><img src="limit-1.jpg" alt="1"><br>上图为扫描索引树</p>
<p>关于MySQL为什么limit时会遍历这么多数据，而不是遍历所需的几条，我们不去深究其设计原理，我们只分析下：<br><code>select c1.id, c1.a, c1.b from t213 c1 right join(select id from t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</code><br>语句为何会比<br><code>select * from t213 where a=4 limit 1000000,10;</code><br>快那么多。</p>
<p>我们知道，MySQL中查询的数据会放在数据页中以便快速获取，<br>而系统表information_schema.innodb_buffer_page保存着InnoDB缓冲池中每个页面的信息。</p>
<p>我们在执行sql后查询innodb_buffer_page表中数据页的个数来判断下两个sql语句的不同之处。</p>
<p>** t213表中有近200万数据 **<br>首先，重启MySQL服务，以便innodb_buffer_page表中t213测试表的数据页为空，然后执行不优化的sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select index_name,count(*) from information_schema.innodb_buffer_page</span><br><span class="line">    -&gt; where index_name in('a','primary') and table_name like '%t213%' group by index_name;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.07</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> test.t213 <span class="keyword">where</span> a=<span class="number">4</span> <span class="keyword">limit</span> <span class="number">1000000</span>,<span class="number">10</span>;</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| id      | a | b   |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| 1000001 | 4 | 123 |</span><br><span class="line">| 1000002 | 4 | 123 |</span><br><span class="line">| 1000003 | 4 | 123 |</span><br><span class="line">| 1000004 | 4 | 123 |</span><br><span class="line">| 1000005 | 4 | 123 |</span><br><span class="line">| 1000006 | 4 | 123 |</span><br><span class="line">| 1000007 | 4 | 123 |</span><br><span class="line">| 1000008 | 4 | 123 |</span><br><span class="line">| 1000009 | 4 | 123 |</span><br><span class="line">| 1000010 | 4 | 123 |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">3.29</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> index_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> information_schema.innodb_buffer_page </span><br><span class="line">    -&gt; <span class="keyword">where</span> index_name <span class="keyword">in</span>(<span class="string">'a'</span>,<span class="string">'primary'</span>) <span class="keyword">and</span> table_name <span class="keyword">like</span> <span class="string">'%t213%'</span> <span class="keyword">group</span> <span class="keyword">by</span> index_name;</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| index_name | count(*) |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| a          |      901 |</span><br><span class="line">| PRIMARY    |     2156 |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure>
<p>可以看到<code>select * from test.t213 where a=4 limit 1000000,10;</code>语句使用到901个二级索引a的索引数据页，使用到2156个聚簇索引数据页。</p>
<p>然后我们再次重启MySQL服务，确保innodb_buffer_page是空的，并执行优化的sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select index_name,count(*) from information_schema.innodb_buffer_page</span><br><span class="line">    -&gt; where index_name in('a','primary') and table_name like '%t213%' group by index_name;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> test.t213 c1 <span class="keyword">right</span> <span class="keyword">join</span>(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> test.t213 <span class="keyword">where</span> a=<span class="number">4</span> <span class="keyword">limit</span> <span class="number">1000000</span>,<span class="number">10</span>)c2 <span class="keyword">on</span> c1.id=c2.id;</span><br><span class="line">+<span class="comment">---------+------+------+---------+</span></span><br><span class="line">| id      | a    | b    | id      |</span><br><span class="line">+<span class="comment">---------+------+------+---------+</span></span><br><span class="line">| 1000001 |    4 |  123 | 1000001 |</span><br><span class="line">| 1000002 |    4 |  123 | 1000002 |</span><br><span class="line">| 1000003 |    4 |  123 | 1000003 |</span><br><span class="line">| 1000004 |    4 |  123 | 1000004 |</span><br><span class="line">| 1000005 |    4 |  123 | 1000005 |</span><br><span class="line">| 1000006 |    4 |  123 | 1000006 |</span><br><span class="line">| 1000007 |    4 |  123 | 1000007 |</span><br><span class="line">| 1000008 |    4 |  123 | 1000008 |</span><br><span class="line">| 1000009 |    4 |  123 | 1000009 |</span><br><span class="line">| 1000010 |    4 |  123 | 1000010 |</span><br><span class="line">+<span class="comment">---------+------+------+---------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.22</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> index_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> information_schema.innodb_buffer_page</span><br><span class="line">    -&gt; <span class="keyword">where</span> index_name <span class="keyword">in</span>(<span class="string">'a'</span>,<span class="string">'primary'</span>) <span class="keyword">and</span> table_name <span class="keyword">like</span> <span class="string">'%t213%'</span> <span class="keyword">group</span> <span class="keyword">by</span> index_name;</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| index_name | count(*) |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| a          |      901 |</span><br><span class="line">| PRIMARY    |        3 |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure>
<p>以上可以看到优化后的sql使用了聚簇索引树的3个数据页。</p>
<p>通过两个对比，我们可以发现，在<br><code>select * from test.t213 c1 right join(select id from test.t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</code><br>语句中，首先执行关联语句 <code>select id from test.t213 where a=4 limit 1000000,10</code><br>使用到覆盖索引的概念，扫描二级索引树并获取到主键id值。<br>之后执行外部sql时，由于id已经找到，直接回表聚簇索引树查找响应id数据即可。</p>
<p>而执行未优化的<code>select * from test.t213 where a=4 limit 1000000,10;</code>语句时，<br>每一次在二级索引获取到的id值都需要回表，执行到最后才判断哪些数据是满足条件的，这样导致费力不讨好，效率很慢。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>高性能MySQL中提供有以下几种limit分页的优化方式：<br>1、join关联方式：<code>select * from test.t213 c1 right join(select id from test.t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</code><br>2、主键递增的表，每次分页记录上次的最大id值，下次分页查询通过判断id &gt; last_id_num来执行：<code>select * from test.t213 where id&gt;1000000 and a=4 limit 10;</code><br>3、主键递增的表，通过between id值来执行分页：<code>select * from test.t213 where a=4 and id between 1000001 and 1000010;</code><br>一般来说2，3两种方法虽然效率更高，但是局限性稍大。</p>
<p>实际项目中，针对分页我们要注意，随着数据量的增加，如果limit使用不当，分页效率会越来越慢，导致接口响应时间增加，用户友好度下降。<br>编写sql时使用合适的limit方式，会减少很多不必要的问题。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/14/hello-world/</url>
    <content><![CDATA[<p>今天搞了半天，搞了个博客页面，用它来记录一些自己的东西。</p>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>1: <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">主题</a><br>2: <a href="https://blog.csdn.net/qq_36759224/article/details/82121420" target="_blank" rel="noopener">设置教程1</a><br>3: <a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">设置教程2</a><br>4: <a href="https://www.cnblogs.com/zhangxiaochn/p/Hexo_Theme_Next.html" target="_blank" rel="noopener">设置教程3</a></p>
<h3 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo</span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<h3 id="推送github"><a href="#推送github" class="headerlink" title="推送github"></a>推送github</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
</search>
