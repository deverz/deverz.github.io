<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL中join关联查询是如何执行的？</title>
    <url>/2020/02/29/mysql-join/</url>
    <content><![CDATA[<p>在上一篇文章&lt;MySQL中如何更好的使用Limit？&gt;中，我们最后写到limit优化的方式之一就是用到了join关联查询，那么多表的关联查询是如何执行的呢？<br>带着这个疑问，我们一起探究下join关联查询的执行步骤！</p>
<h3 id="一、实验环境"><a href="#一、实验环境" class="headerlink" title="一、实验环境"></a>一、实验环境</h3><ul>
<li><p>1、MySQL版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| version() |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 8.0.18    |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、实验表结构 t1数据100条，t2数据1000条</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc t1;</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| id    | int(11) | NO   | PRI | NULL    |       |</span><br><span class="line">| a     | int(11) | YES  | MUL | NULL    |       |</span><br><span class="line">| b     | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t1;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|      100 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">desc</span> t2;</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| id    | int(11) | NO   | PRI | NULL    |       |</span><br><span class="line">| a     | int(11) | YES  | MUL | NULL    |       |</span><br><span class="line">| b     | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t2;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|     1000 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="二、驱动表"><a href="#二、驱动表" class="headerlink" title="二、驱动表"></a>二、驱动表</h3><ul>
<li>1、驱动表的概念</li>
</ul>
<p>提到join，就不得不说到驱动表。<br>驱动表：在关联查询中首先执行的表，叫做驱动表。在使用join时，默认会有MySQL的优化器去选择合适表作为驱动表。</p>
<p>在join语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。</p>
<p>执行以下sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 join t2 on t1.a=t2.a;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref       | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | a             | NULL | NULL    | NULL      |  100 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ref  | a             | a    | 5       | test.t1.a |    1 |   100.00 | NULL        |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>在 explain 中，第一行的表就是驱动表。可以看出，上面的sql语句的驱动表为t1表。<br>根据row字段信息，可以看出，t1表进行了全表扫描，t2表使用了字段a上的索引。</p>
<ul>
<li>2、如何选取驱动表</li>
</ul>
<p><em>a. MySQL自动选取</em></p>
<p>一般来说，MySQL会选取小表作为驱动表，注意，这里的小表不是总数据量少的那张表，而是根据sql中的表过滤条件去决定的。</p>
<p>执行以下sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sql1</span></span><br><span class="line">mysql&gt; explain select * from t1 join t2 on t2.b=t1.b;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  100 |   100.00 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1000 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sql2</span></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> t2.b=t1.b <span class="keyword">where</span> t2.id&lt;<span class="number">50</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   49 |   100.00 | Using where                                        |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |  100 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>以上实验可以看出：</p>
<p>sql1的驱动表为t1表，因为在没有其他过滤条件的情况下，t1表只有100条数据，优先以小表作为驱动表。<br>sql2的驱动表为t2表，因为where条件中的 <code>t2.id&lt;50</code> 使得t2表过滤之后只有49条数据，所以t2表是小表。</p>
<p><em>b. 手动选取</em></p>
<p>使用 straight_join 代替 join 其将强制选取第一张表作为驱动表。<br>执行下上面的sql2，将join换为straight_join。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 straight_join t2 on t2.b=t1.b where t2.id&lt;50;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |  100 |   100.00 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   49 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="三、关联查询算法"><a href="#三、关联查询算法" class="headerlink" title="三、关联查询算法"></a>三、关联查询算法</h3><p>MySQL中join关联查询共有四种查询算法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Simple Nested-Loop join,</span><br><span class="line">Block Nested-Loop join,</span><br><span class="line">Index Nested-Loop join，</span><br><span class="line">Batched Key Access join</span><br></pre></td></tr></table></figure>
<p>在使用索引关联的情况下，有Index Nested-Loop join和Batched Key Access join两种算法；<br>在不使用索引关联的情况下，有Simple Nested-Loop join和Block Nested-Loop join两种算法。</p>
<ul>
<li>1、索引关联情况（t1,t2表的a字段有索引)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 join t2 on t2.a=t1.a where t2.id&lt;50;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref       | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY,a     | PRIMARY | 4       | NULL      |   49 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref   | a             | a       | 5       | test.t2.a |    1 |   100.00 | NULL        |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>执行步骤为：<br>1、MySQL优化器根据过滤条件得出驱动表为t2；<br>2、根据 <code>t2.id&lt;50，t2.*</code> 查询到一行t2.id=1的数据，拿到t2.a的值和t1.a做关联；<br>3、搜寻t1.a索引树，找到t1.id，回表查询t1.*数据；<br>4、组成整体数据行，放入结果集中；<br>5、循环1-4步骤，直到取完数据。</p>
<p>执行过程图：<br><img src="join-index.jpg" alt="1"></p>
<p>以上流程就是Index Nested-Loop join算法（索引嵌套循环连接）的执行过程，可以发现，如果在被驱动表(t.1)的索引树上不存在需要查询的所有字段，则需要回表到聚簇索引上查询，<br>每次回表都是一次随机查询，对于MySQL来说，性能并不是很好。</p>
<p>因此，MySQL在5.6引入了Batched Key Access join算法（成批密钥访问连接）。<br>针对上面的Index Nested-Loop join算法实例，该算法的执行逻辑为：<br>1、MySQL优化器根据过滤条件得出驱动表为t2；<br>2、根据 <code>t2.id&lt;50，t2.*</code> 查询到一行t2.id=1的数据；<br>3、将第2步的行数据放到join_buffer中，循环第二步，直到join_buffer放满；<br>4、根据join_buffer中的t2.a的值和t1.a做关联，搜寻t1.a索引树，找到t1.id；<br>5、将第3步的索引数据放到read_rnd_buffer中，并将read_rnd_buffer中的t1.id排序；<br>6、循环3~4步骤，直到read_rnd_buffer放满；<br>7、通过MRR(Multi-Range Read)将read_rnd_buffer中的数据进行回表查询；<br>8、将回表的查询结果和join_buffer中的数据组合成整体数据行，放入结果集中。</p>
<p>执行过程图：<br><img src="join-bka.jpg" alt="2"></p>
<p>在以上Batched Key Access join算法执行步骤中，其优化了两点：<br>1、驱动表查询到的行数据先缓存在join_buffer中，之后批量访问被驱动表索引树；<br>2、被驱动表索引行数据缓存在read_rnd_buffer中并按照主键进行排序，之后MRR顺序回表查询数据。<br>Batched Key Access join算法避免了多次访问被驱动表索引树，并将随机回表变为顺序回表，大大提升了查询效率。</p>
<ul>
<li>2、无索引关联情况（t1,t2表的b字段无索引）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 join t2 on t2.b=t1.b where t2.id&lt;50;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   49 |   100.00 | Using where                                        |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |  100 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>根据explain sql执行计划，我们在Extra字段中可以看到，其使用到了Block Nested-Loop join算法（块嵌套循环连接）。<br>Block Nested-Loop join算法和Batched Key Access join算法执行步骤类似，只是没有read_rnd_buffer。</p>
<p>其执行步骤为：<br>1、MySQL优化器根据过滤条件得出驱动表为t1；<br>2、根据 <code>t2.id&lt;50，t2.*</code> 查询到一行t2.id=1的数据；<br>3、将第2步的行数据放到join_buffer中，循环第二步，直到join_buffer放满；<br>4、根据join_buffer中的t2.b的值和t1.b做关联，全表扫描t1，批量取出行数据；<br>5、将全表扫描查询结果和join_buffer中的数据组合成整体数据行，放入结果集中。</p>
<p>执行过程图：<br><img src="join-bnl.jpg" alt="3"></p>
<p>关于Simple Nested-Loop join算法，MySQL已经不再使用，其执行步骤为Block Nested-Loop join算法执行步骤中去掉join_buffer内容。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>此篇文章我们介绍了join关联查询下，驱动表的概念以及四种关联查询算法。</p>
<p>Batched Key Access join算法（BKA）是最优的join优化解决方案，使用BKA可以大大的提高sql的执行效率。<br>在MySQL中Batched Key Access join算法默认并未开启，需要在执行sql前启用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动BKA &amp; MMR</span></span><br><span class="line">mysql&gt; set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select t1.*,t2.* from t1 join t2 on t2.a=t1.a where t2.id&lt;80;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+----------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref       | rows | filtered | Extra                                  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+----------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY,a     | PRIMARY | 4       | NULL      |   79 |   100.00 | Using where                            |</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref   | a             | a       | 5       | test.t2.a |    1 |   100.00 | Using join buffer (Batched Key Access) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+----------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>关联查询在无索引关联时，对被驱动表的全表扫描十分浪费资源，所以在平时我们编写关联sql查询时，在数据表中有大量数据时，应尽量避免无索引关联的情况，on后的语句中的关联条件应为其建立必要的索引，实在无法为字段建立索引，则应考虑其他方式进行关联查询。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL中如何更好的使用Limit？</title>
    <url>/2020/02/12/mysql-limit/</url>
    <content><![CDATA[<p>在业务中实现分页功能就离不了MySQL的limit语句，而随着数据表中数据量的增加，则不可避免会导致查询时偏移量过大。<br>我们知道随着偏移量的增大，limit语句的耗时会增加，接下来我们就探讨下如何去更好的处理limit的耗时问题。</p>
<h3 id="一、实验"><a href="#一、实验" class="headerlink" title="一、实验"></a>一、实验</h3><p>1、MySQL版本：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| version() |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 8.0.18    |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>2、实验表结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc t213;</span><br><span class="line">+<span class="comment">-------+------------------+------+-----+---------+----------------+</span></span><br><span class="line">| Field | Type             | Null | Key | Default | Extra          |</span><br><span class="line">+<span class="comment">-------+------------------+------+-----+---------+----------------+</span></span><br><span class="line">| id    | int(10)          | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| a     | int(10) unsigned | NO   | MUL | 0       |                |</span><br><span class="line">| b     | int(10) unsigned | NO   |     | 0       |                |</span><br><span class="line">+<span class="comment">-------+------------------+------+-----+---------+----------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>其中，id为自增主键，字段a为普通索引</p>
<p>3、实验数据量近200万：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(*) from t213;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|  1979311 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.11</span> sec)</span><br></pre></td></tr></table></figure>

<p>4、开始测试：<br>当偏移量为100万时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t213 where a=4 limit 1000000,10;</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| id      | a | b   |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| 1000001 | 4 | 123 |</span><br><span class="line">| 1000002 | 4 | 123 |</span><br><span class="line">| 1000003 | 4 | 123 |</span><br><span class="line">| 1000004 | 4 | 123 |</span><br><span class="line">| 1000005 | 4 | 123 |</span><br><span class="line">| 1000006 | 4 | 123 |</span><br><span class="line">| 1000007 | 4 | 123 |</span><br><span class="line">| 1000008 | 4 | 123 |</span><br><span class="line">| 1000009 | 4 | 123 |</span><br><span class="line">| 1000010 | 4 | 123 |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">2.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>我们知道以上的方法效率并不高，一般我们在数据量大的数据表中，不直接limit，而是通过连接去先查询id，再查询字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select c1.id, c1.a, c1.b from t213 c1 right join(select id from t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</span><br><span class="line">+<span class="comment">---------+------+------+</span></span><br><span class="line">| id      | a    | b    |</span><br><span class="line">+<span class="comment">---------+------+------+</span></span><br><span class="line">| 1000001 |    4 |  123 |</span><br><span class="line">| 1000002 |    4 |  123 |</span><br><span class="line">| 1000003 |    4 |  123 |</span><br><span class="line">| 1000004 |    4 |  123 |</span><br><span class="line">| 1000005 |    4 |  123 |</span><br><span class="line">| 1000006 |    4 |  123 |</span><br><span class="line">| 1000007 |    4 |  123 |</span><br><span class="line">| 1000008 |    4 |  123 |</span><br><span class="line">| 1000009 |    4 |  123 |</span><br><span class="line">| 1000010 |    4 |  123 |</span><br><span class="line">+<span class="comment">---------+------+------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.16</span> sec)</span><br></pre></td></tr></table></figure>
<p>这两种方法的效率相差巨大，那么为什么会如此呢？MySQL是如何执行相差巨大的两条语句的呢？</p>
<h3 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h3><p>根据高性能MySQL中关于limit的说明：<br>limit语句在偏移量巨大时，如<code>select * from t213 where a=4 limit 1000000,10;</code>。<br>对效率的影响主要在于MySQL会查询1,000,010条数据，并取最后10条，抛弃掉前面的1,000,000条。</p>
<p>也就是说，MySQL耗时耗力找到的数据，绝大部分都得废弃！<br>MySQL查找索引a的二级索引树，然后根据二级索引树上的主键值回表到聚簇索引树上进行扫描数据，为了limit而重复大量无用的IO操作<br><img src="limit-1.jpg" alt="1"><br>上图为扫描索引树</p>
<p>关于MySQL为什么limit时会遍历这么多数据，而不是遍历所需的几条，我们不去深究其设计原理，我们只分析下：<br><code>select c1.id, c1.a, c1.b from t213 c1 right join(select id from t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</code><br>语句为何会比<br><code>select * from t213 where a=4 limit 1000000,10;</code><br>快那么多。</p>
<p>我们知道，MySQL中查询的数据会放在数据页中以便快速获取，<br>而系统表information_schema.innodb_buffer_page保存着InnoDB缓冲池中每个页面的信息。</p>
<p>我们在执行sql后查询innodb_buffer_page表中数据页的个数来判断下两个sql语句的不同之处。</p>
<p>** t213表中有近200万数据 **<br>首先，重启MySQL服务，以便innodb_buffer_page表中t213测试表的数据页为空，然后执行不优化的sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select index_name,count(*) from information_schema.innodb_buffer_page</span><br><span class="line">    -&gt; where index_name in('a','primary') and table_name like '%t213%' group by index_name;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.07</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> test.t213 <span class="keyword">where</span> a=<span class="number">4</span> <span class="keyword">limit</span> <span class="number">1000000</span>,<span class="number">10</span>;</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| id      | a | b   |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| 1000001 | 4 | 123 |</span><br><span class="line">| 1000002 | 4 | 123 |</span><br><span class="line">| 1000003 | 4 | 123 |</span><br><span class="line">| 1000004 | 4 | 123 |</span><br><span class="line">| 1000005 | 4 | 123 |</span><br><span class="line">| 1000006 | 4 | 123 |</span><br><span class="line">| 1000007 | 4 | 123 |</span><br><span class="line">| 1000008 | 4 | 123 |</span><br><span class="line">| 1000009 | 4 | 123 |</span><br><span class="line">| 1000010 | 4 | 123 |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">3.29</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> index_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> information_schema.innodb_buffer_page </span><br><span class="line">    -&gt; <span class="keyword">where</span> index_name <span class="keyword">in</span>(<span class="string">'a'</span>,<span class="string">'primary'</span>) <span class="keyword">and</span> table_name <span class="keyword">like</span> <span class="string">'%t213%'</span> <span class="keyword">group</span> <span class="keyword">by</span> index_name;</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| index_name | count(*) |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| a          |      901 |</span><br><span class="line">| PRIMARY    |     2156 |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure>
<p>可以看到<code>select * from test.t213 where a=4 limit 1000000,10;</code>语句使用到901个二级索引a的索引数据页，使用到2156个聚簇索引数据页。</p>
<p>然后我们再次重启MySQL服务，确保innodb_buffer_page是空的，并执行优化的sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select index_name,count(*) from information_schema.innodb_buffer_page</span><br><span class="line">    -&gt; where index_name in('a','primary') and table_name like '%t213%' group by index_name;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> test.t213 c1 <span class="keyword">right</span> <span class="keyword">join</span>(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> test.t213 <span class="keyword">where</span> a=<span class="number">4</span> <span class="keyword">limit</span> <span class="number">1000000</span>,<span class="number">10</span>)c2 <span class="keyword">on</span> c1.id=c2.id;</span><br><span class="line">+<span class="comment">---------+------+------+---------+</span></span><br><span class="line">| id      | a    | b    | id      |</span><br><span class="line">+<span class="comment">---------+------+------+---------+</span></span><br><span class="line">| 1000001 |    4 |  123 | 1000001 |</span><br><span class="line">| 1000002 |    4 |  123 | 1000002 |</span><br><span class="line">| 1000003 |    4 |  123 | 1000003 |</span><br><span class="line">| 1000004 |    4 |  123 | 1000004 |</span><br><span class="line">| 1000005 |    4 |  123 | 1000005 |</span><br><span class="line">| 1000006 |    4 |  123 | 1000006 |</span><br><span class="line">| 1000007 |    4 |  123 | 1000007 |</span><br><span class="line">| 1000008 |    4 |  123 | 1000008 |</span><br><span class="line">| 1000009 |    4 |  123 | 1000009 |</span><br><span class="line">| 1000010 |    4 |  123 | 1000010 |</span><br><span class="line">+<span class="comment">---------+------+------+---------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.22</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> index_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> information_schema.innodb_buffer_page</span><br><span class="line">    -&gt; <span class="keyword">where</span> index_name <span class="keyword">in</span>(<span class="string">'a'</span>,<span class="string">'primary'</span>) <span class="keyword">and</span> table_name <span class="keyword">like</span> <span class="string">'%t213%'</span> <span class="keyword">group</span> <span class="keyword">by</span> index_name;</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| index_name | count(*) |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| a          |      901 |</span><br><span class="line">| PRIMARY    |        3 |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure>
<p>以上可以看到优化后的sql使用了聚簇索引树的3个数据页。</p>
<p>通过两个对比，我们可以发现，在<br><code>select * from test.t213 c1 right join(select id from test.t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</code><br>语句中，首先执行关联语句 <code>select id from test.t213 where a=4 limit 1000000,10</code><br>使用到覆盖索引的概念，扫描二级索引树并获取到主键id值。<br>之后执行外部sql时，由于id已经找到，直接回表聚簇索引树查找响应id数据即可。</p>
<p>而执行未优化的<code>select * from test.t213 where a=4 limit 1000000,10;</code>语句时，<br>每一次在二级索引获取到的id值都需要回表，执行到最后才判断哪些数据是满足条件的，这样导致费力不讨好，效率很慢。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>高性能MySQL中提供有以下几种limit分页的优化方式：<br>1、join关联方式：<code>select * from test.t213 c1 right join(select id from test.t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</code><br>2、主键递增的表，每次分页记录上次的最大id值，下次分页查询通过判断id &gt; last_id_num来执行：<code>select * from test.t213 where id&gt;1000000 and a=4 limit 10;</code><br>3、主键递增的表，通过between id值来执行分页：<code>select * from test.t213 where a=4 and id between 1000001 and 1000010;</code><br>一般来说2，3两种方法虽然效率更高，但是局限性稍大。</p>
<p>实际项目中，针对分页我们要注意，随着数据量的增加，如果limit使用不当，分页效率会越来越慢，导致接口响应时间增加，用户友好度下降。<br>编写sql时使用合适的limit方式，会减少很多不必要的问题。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/14/hello-world/</url>
    <content><![CDATA[<p>今天搞了半天，搞了个博客页面，用它来记录一些自己的东西。</p>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>1: <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">主题</a><br>2: <a href="https://blog.csdn.net/qq_36759224/article/details/82121420" target="_blank" rel="noopener">设置教程1</a><br>3: <a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">设置教程2</a><br>4: <a href="https://www.cnblogs.com/zhangxiaochn/p/Hexo_Theme_Next.html" target="_blank" rel="noopener">设置教程3</a></p>
<h3 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo</span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<h3 id="推送github"><a href="#推送github" class="headerlink" title="推送github"></a>推送github</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
</search>
