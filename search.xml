<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL中如何更好的使用Limit？</title>
    <url>/2020/02/12/mysql-limit/</url>
    <content><![CDATA[<p>在业务中实现分页功能就离不了MySQL的limit语句，而随着数据表中数据量的增加，则不可避免会导致查询时偏移量过大。<br>我们知道随着偏移量的增大，limit语句的耗时会增加，接下来我们就探讨下如何去更好的处理limit的耗时问题。</p>
<h3 id="一、实验"><a href="#一、实验" class="headerlink" title="一、实验"></a>一、实验</h3><p>1、MySQL版本：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| version() |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 8.0.18    |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>2、实验表结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc t213;</span><br><span class="line">+<span class="comment">-------+------------------+------+-----+---------+----------------+</span></span><br><span class="line">| Field | Type             | Null | Key | Default | Extra          |</span><br><span class="line">+<span class="comment">-------+------------------+------+-----+---------+----------------+</span></span><br><span class="line">| id    | int(10)          | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| a     | int(10) unsigned | NO   | MUL | 0       |                |</span><br><span class="line">| b     | int(10) unsigned | NO   |     | 0       |                |</span><br><span class="line">+<span class="comment">-------+------------------+------+-----+---------+----------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>其中，id为自增主键，字段a为普通索引</p>
<p>3、实验数据量近200万：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(*) from t213;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|  1979311 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.11</span> sec)</span><br></pre></td></tr></table></figure>

<p>4、开始测试：<br>当偏移量为100万时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t213 where a=4 limit 1000000,10;</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| id      | a | b   |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| 1000001 | 4 | 123 |</span><br><span class="line">| 1000002 | 4 | 123 |</span><br><span class="line">| 1000003 | 4 | 123 |</span><br><span class="line">| 1000004 | 4 | 123 |</span><br><span class="line">| 1000005 | 4 | 123 |</span><br><span class="line">| 1000006 | 4 | 123 |</span><br><span class="line">| 1000007 | 4 | 123 |</span><br><span class="line">| 1000008 | 4 | 123 |</span><br><span class="line">| 1000009 | 4 | 123 |</span><br><span class="line">| 1000010 | 4 | 123 |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">2.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>我们知道以上的方法效率并不高，一般我们在数据量大的数据表中，不直接limit，而是通过连接去先查询id，再查询字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select c1.id, c1.a, c1.b from t213 c1 right join(select id from t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</span><br><span class="line">+<span class="comment">---------+------+------+</span></span><br><span class="line">| id      | a    | b    |</span><br><span class="line">+<span class="comment">---------+------+------+</span></span><br><span class="line">| 1000001 |    4 |  123 |</span><br><span class="line">| 1000002 |    4 |  123 |</span><br><span class="line">| 1000003 |    4 |  123 |</span><br><span class="line">| 1000004 |    4 |  123 |</span><br><span class="line">| 1000005 |    4 |  123 |</span><br><span class="line">| 1000006 |    4 |  123 |</span><br><span class="line">| 1000007 |    4 |  123 |</span><br><span class="line">| 1000008 |    4 |  123 |</span><br><span class="line">| 1000009 |    4 |  123 |</span><br><span class="line">| 1000010 |    4 |  123 |</span><br><span class="line">+<span class="comment">---------+------+------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.16</span> sec)</span><br></pre></td></tr></table></figure>
<p>这两种方法的效率相差巨大，那么为什么会如此呢？MySQL是如何执行相差巨大的两条语句的呢？</p>
<h3 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h3><p>根据高性能MySQL中关于limit的说明：<br>limit语句在偏移量巨大时，如<code>select * from t213 where a=4 limit 1000000,10;</code>。<br>对效率的影响主要在于MySQL会查询1,000,010条数据，并取最后10条，抛弃掉前面的1,000,000条。</p>
<p>也就是说，MySQL耗时耗力找到的数据，绝大部分都得废弃！<br>MySQL查找索引a的二级索引树，然后根据二级索引树上的主键值回表到聚簇索引树上进行扫描数据，为了limit而重复大量无用的IO操作<br><img src="limit-1.jpg" alt="1"><br>上图为扫描索引树</p>
<p>关于MySQL为什么limit时会遍历这么多数据，而不是遍历所需的几条，我们不去深究其设计原理，我们只分析下：<br><code>select c1.id, c1.a, c1.b from t213 c1 right join(select id from t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</code><br>语句为何会比<br><code>select * from t213 where a=4 limit 1000000,10;</code><br>快那么多。</p>
<p>我们知道，MySQL中查询的数据会放在数据页中以便快速获取，<br>而系统表information_schema.innodb_buffer_page保存着InnoDB缓冲池中每个页面的信息。</p>
<p>我们在执行sql后查询innodb_buffer_page表中数据页的个数来判断下两个sql语句的不同之处。</p>
<p>** t213表中有近200万数据 **<br>首先，重启MySQL服务，以便innodb_buffer_page表中t213测试表的数据页为空，然后执行不优化的sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select index_name,count(*) from information_schema.innodb_buffer_page</span><br><span class="line">    -&gt; where index_name in('a','primary') and table_name like '%t213%' group by index_name;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.07</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> test.t213 <span class="keyword">where</span> a=<span class="number">4</span> <span class="keyword">limit</span> <span class="number">1000000</span>,<span class="number">10</span>;</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| id      | a | b   |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">| 1000001 | 4 | 123 |</span><br><span class="line">| 1000002 | 4 | 123 |</span><br><span class="line">| 1000003 | 4 | 123 |</span><br><span class="line">| 1000004 | 4 | 123 |</span><br><span class="line">| 1000005 | 4 | 123 |</span><br><span class="line">| 1000006 | 4 | 123 |</span><br><span class="line">| 1000007 | 4 | 123 |</span><br><span class="line">| 1000008 | 4 | 123 |</span><br><span class="line">| 1000009 | 4 | 123 |</span><br><span class="line">| 1000010 | 4 | 123 |</span><br><span class="line">+<span class="comment">---------+---+-----+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">3.29</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> index_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> information_schema.innodb_buffer_page </span><br><span class="line">    -&gt; <span class="keyword">where</span> index_name <span class="keyword">in</span>(<span class="string">'a'</span>,<span class="string">'primary'</span>) <span class="keyword">and</span> table_name <span class="keyword">like</span> <span class="string">'%t213%'</span> <span class="keyword">group</span> <span class="keyword">by</span> index_name;</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| index_name | count(*) |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| a          |      901 |</span><br><span class="line">| PRIMARY    |     2156 |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure>
<p>可以看到<code>select * from test.t213 where a=4 limit 1000000,10;</code>语句使用到901个二级索引a的索引数据页，使用到2156个聚簇索引数据页。</p>
<p>然后我们再次重启MySQL服务，确保innodb_buffer_page是空的，并执行优化的sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select index_name,count(*) from information_schema.innodb_buffer_page</span><br><span class="line">    -&gt; where index_name in('a','primary') and table_name like '%t213%' group by index_name;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> test.t213 c1 <span class="keyword">right</span> <span class="keyword">join</span>(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> test.t213 <span class="keyword">where</span> a=<span class="number">4</span> <span class="keyword">limit</span> <span class="number">1000000</span>,<span class="number">10</span>)c2 <span class="keyword">on</span> c1.id=c2.id;</span><br><span class="line">+<span class="comment">---------+------+------+---------+</span></span><br><span class="line">| id      | a    | b    | id      |</span><br><span class="line">+<span class="comment">---------+------+------+---------+</span></span><br><span class="line">| 1000001 |    4 |  123 | 1000001 |</span><br><span class="line">| 1000002 |    4 |  123 | 1000002 |</span><br><span class="line">| 1000003 |    4 |  123 | 1000003 |</span><br><span class="line">| 1000004 |    4 |  123 | 1000004 |</span><br><span class="line">| 1000005 |    4 |  123 | 1000005 |</span><br><span class="line">| 1000006 |    4 |  123 | 1000006 |</span><br><span class="line">| 1000007 |    4 |  123 | 1000007 |</span><br><span class="line">| 1000008 |    4 |  123 | 1000008 |</span><br><span class="line">| 1000009 |    4 |  123 | 1000009 |</span><br><span class="line">| 1000010 |    4 |  123 | 1000010 |</span><br><span class="line">+<span class="comment">---------+------+------+---------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.22</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> index_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> information_schema.innodb_buffer_page</span><br><span class="line">    -&gt; <span class="keyword">where</span> index_name <span class="keyword">in</span>(<span class="string">'a'</span>,<span class="string">'primary'</span>) <span class="keyword">and</span> table_name <span class="keyword">like</span> <span class="string">'%t213%'</span> <span class="keyword">group</span> <span class="keyword">by</span> index_name;</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| index_name | count(*) |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">| a          |      901 |</span><br><span class="line">| PRIMARY    |        3 |</span><br><span class="line">+<span class="comment">------------+----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure>
<p>以上可以看到优化后的sql使用了聚簇索引树的3个数据页。</p>
<p>通过两个对比，我们可以发现，在<br><code>select * from test.t213 c1 right join(select id from test.t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</code><br>语句中，首先执行关联语句 <code>select id from test.t213 where a=4 limit 1000000,10</code><br>使用到覆盖索引的概念，扫描二级索引树并获取到主键id值。<br>之后执行外部sql时，由于id已经找到，直接回表聚簇索引树查找响应id数据即可。</p>
<p>而执行未优化的<code>select * from test.t213 where a=4 limit 1000000,10;</code>语句时，<br>每一次在二级索引获取到的id值都需要回表，执行到最后才判断哪些数据是满足条件的，这样导致费力不讨好，效率很慢。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>高性能MySQL中提供有以下几种limit分页的优化方式：<br>1、join关联方式：<code>select * from test.t213 c1 right join(select id from test.t213 where a=4 limit 1000000,10)c2 on c1.id=c2.id;</code><br>2、主键递增的表，每次分页记录上次的最大id值，下次分页查询通过判断id &gt; last_id_num来执行：<code>select * from test.t213 where id&gt;1000000 and a=4 limit 10;</code><br>3、主键递增的表，通过between id值来执行分页：<code>select * from test.t213 where a=4 and id between 1000001 and 1000010;</code><br>一般来说2，3两种方法虽然效率更高，但是局限性稍大。</p>
<p>实际项目中，针对分页我们要注意，随着数据量的增加，如果limit使用不当，分页效率会越来越慢，导致接口响应时间增加，用户友好度下降。<br>编写sql时使用合适的limit方式，会减少很多不必要的问题。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/14/hello-world/</url>
    <content><![CDATA[<p>今天搞了半天，搞了个博客页面，用它来记录一些自己的东西。</p>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>1: <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">主题</a><br>2: <a href="https://blog.csdn.net/qq_36759224/article/details/82121420" target="_blank" rel="noopener">设置教程1</a><br>3: <a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">设置教程2</a><br>4: <a href="https://www.cnblogs.com/zhangxiaochn/p/Hexo_Theme_Next.html" target="_blank" rel="noopener">设置教程3</a></p>
<h3 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo</span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<h3 id="推送github"><a href="#推送github" class="headerlink" title="推送github"></a>推送github</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
</search>
